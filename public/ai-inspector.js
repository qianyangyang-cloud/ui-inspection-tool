/**
 * AI Inspection Core Module
 * Integrated pixel difference detection + UI element classification + image cropping + Qwen report generation
 */

class AIInspector {
  constructor() {
    this.canvas = null;
    this.ctx = null;
  }

  /**
   * Main entry: Execute AI inspection
   * @param {string} designImageData - Design image base64 data
   * @param {HTMLCanvasElement} webpageCanvas - Webpage screenshot canvas
   * @returns {Object} Inspection results
   */
  async executeAIInspection(designImageData, webpageCanvas) {
    console.log('üöÄ Starting AI inspection workflow...');
    
    try {
      
      // Step 1: Pixel difference detection
      const diffResult = await this.pixelDifferenceDetection(designImageData, webpageCanvas);
      
      if (!diffResult.regions || diffResult.regions.length === 0) {
        return {
          success: true,
          similarity: diffResult.similarity,
          regions: [],
          overlayImage: diffResult.overlayCanvas.toDataURL(),
          message: 'Page is highly consistent with design mockup, no significant differences found'
        };
      }

      // Step 2: Smart UI element classification
      const classifiedRegions = this.classifyUIElements(diffResult.regions, webpageCanvas);

      // Step 3: Generate region screenshots
      const regionScreenshots = await this.generateRegionScreenshots(
        classifiedRegions, 
        diffResult.cleanOverlayCanvas || diffResult.overlayCanvas
      );

      // Step 4: Generate problem descriptions  
      const problemDescriptions = await this.generateProblemDescriptions(regionScreenshots);

      // Step 5: Format into product-required problem list format
      const problemAreas = this.formatToProblemList(
        classifiedRegions,
        regionScreenshots,
        problemDescriptions
      );

      console.log(`‚úÖ AI inspection complete, found ${problemAreas.length} issues`);

      return {
        success: true,
        similarity: diffResult.similarity,
        regions: problemAreas,
        overlayImage: diffResult.overlayCanvas.toDataURL()
      };

    } catch (error) {
      console.error('‚ùå AI inspection execution failed:', error);
      return {
        success: false,
        error: error.message,
        regions: []
      };
    }
  }

  /**
   * Pixel difference detection
   */
  async pixelDifferenceDetection(designImageData, webpageCanvas) {
    console.log('üîç Executing pixel difference detection...');

    // Load design image
    const designImg = await this.loadImage(designImageData);
    
    // Unify dimensions
    const targetWidth = Math.min(designImg.width, webpageCanvas.width);
    const targetHeight = Math.min(designImg.height, webpageCanvas.height);

    // Create unified dimension canvas
    const designCanvas = this.createCanvas(targetWidth, targetHeight);
    const designCtx = designCanvas.getContext('2d');
    designCtx.drawImage(designImg, 0, 0, targetWidth, targetHeight);

    const webCanvas = this.createCanvas(targetWidth, targetHeight);
    const webCtx = webCanvas.getContext('2d');
    webCtx.drawImage(webpageCanvas, 0, 0, targetWidth, targetHeight);

    // Get pixel data
    const designData = designCtx.getImageData(0, 0, targetWidth, targetHeight);
    const webData = webCtx.getImageData(0, 0, targetWidth, targetHeight);

    // Calculate differences
    const diffMap = this.calculatePixelDifference(designData, webData);
    const similarity = this.calculateSimilarity(diffMap);

    // Detect difference regions
    const regions = this.detectDifferenceRegions(diffMap, targetWidth, targetHeight);
    
    // Merge nearby regions
    const mergedRegions = this.mergeNearbyRegions(regions);

    // Create overlay image (for final display)
    const overlayCanvas = this.createOverlayCanvas(designCanvas, webCanvas, mergedRegions);
    
    // Create overlay without numbers (for screenshots)
    const cleanOverlayCanvas = this.createOverlayCanvasWithoutNumbers(designCanvas, webCanvas, mergedRegions);

    console.log(`Found ${mergedRegions.length} difference regions, overall similarity: ${(similarity*100).toFixed(1)}%`);

    return {
      regions: mergedRegions,
      similarity: similarity,
      overlayCanvas: overlayCanvas,
      cleanOverlayCanvas: cleanOverlayCanvas
    };
  }

  /**
   * Calculate pixel differences
   */
  calculatePixelDifference(designData, webData) {
    const diffMap = new Uint8Array(designData.width * designData.height);
    
    for (let i = 0; i < designData.data.length; i += 4) {
      const pixelIndex = i / 4;
      
      // RGB difference calculation
      const r1 = designData.data[i], g1 = designData.data[i + 1], b1 = designData.data[i + 2];
      const r2 = webData.data[i], g2 = webData.data[i + 1], b2 = webData.data[i + 2];
      
      const diff = Math.sqrt((r1-r2)**2 + (g1-g2)**2 + (b1-b2)**2);
      diffMap[pixelIndex] = diff > 25 ? diff : 0; // Threshold filtering
    }
    
    return diffMap;
  }

  /**
   * Detect difference regions
   */
  detectDifferenceRegions(diffMap, width, height) {
    // Binarization processing
    const binaryMap = new Uint8Array(width * height);
    for (let i = 0; i < diffMap.length; i++) {
      binaryMap[i] = diffMap[i] > 0 ? 255 : 0;
    }

    // Morphological operations (simplified version)
    const processedMap = this.morphologyClose(binaryMap, width, height, 15);
    
    // Connected region detection
    const regions = this.findConnectedRegions(processedMap, width, height);
    
    return regions.filter(region => region.area > 500); // Filter small regions
  }

  /**
   * ÂΩ¢ÊÄÅÂ≠¶Èó≠ËøêÁÆóÔºàÁÆÄÂåñÁâàÔºâ
   */
  morphologyClose(binaryMap, width, height, kernelSize) {
    const result = new Uint8Array(binaryMap.length);
    const half = Math.floor(kernelSize / 2);
    
    // ËÜ®ËÉÄ
    for (let y = half; y < height - half; y++) {
      for (let x = half; x < width - half; x++) {
        let hasWhite = false;
        
        for (let ky = -half; ky <= half; ky++) {
          for (let kx = -half; kx <= half; kx++) {
            const idx = (y + ky) * width + (x + kx);
            if (binaryMap[idx] > 0) {
              hasWhite = true;
              break;
            }
          }
          if (hasWhite) break;
        }
        
        result[y * width + x] = hasWhite ? 255 : 0;
      }
    }
    
    // ËÖêËöÄ
    const final = new Uint8Array(result.length);
    for (let y = half; y < height - half; y++) {
      for (let x = half; x < width - half; x++) {
        let allWhite = true;
        
        for (let ky = -half; ky <= half; ky++) {
          for (let kx = -half; kx <= half; kx++) {
            const idx = (y + ky) * width + (x + kx);
            if (result[idx] === 0) {
              allWhite = false;
              break;
            }
          }
          if (!allWhite) break;
        }
        
        final[y * width + x] = allWhite ? 255 : 0;
      }
    }
    
    return final;
  }

  /**
   * ËøûÈÄöÂå∫ÂüüÊ£ÄÊµã
   */
  findConnectedRegions(binaryMap, width, height) {
    const visited = new Array(width * height).fill(false);
    const regions = [];
    let regionId = 1;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = y * width + x;
        
        if (binaryMap[idx] > 0 && !visited[idx]) {
          const region = this.floodFill(binaryMap, visited, x, y, width, height, regionId++);
          if (region.area > 0) {
            regions.push(region);
          }
        }
      }
    }

    return regions;
  }

  /**
   * Ê¥™Ê∞¥Â°´ÂÖÖÁÆóÊ≥ï
   */
  floodFill(binaryMap, visited, startX, startY, width, height, regionId) {
    const stack = [{x: startX, y: startY}];
    const points = [];
    let minX = startX, maxX = startX, minY = startY, maxY = startY;

    while (stack.length > 0) {
      const {x, y} = stack.pop();
      const idx = y * width + x;

      if (x < 0 || x >= width || y < 0 || y >= height || 
          visited[idx] || binaryMap[idx] === 0) {
        continue;
      }

      visited[idx] = true;
      points.push({x, y});
      
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);

      // 4ËøûÈÄö
      stack.push({x: x+1, y: y});
      stack.push({x: x-1, y: y});
      stack.push({x: x, y: y+1});
      stack.push({x: x, y: y-1});
    }

    // Êâ©Â±ïËæπÁïå
    const margin = 15;
    return {
      id: regionId,
      x: Math.max(0, minX - margin),
      y: Math.max(0, minY - margin),
      width: Math.min(width, maxX - minX + 1 + margin * 2),
      height: Math.min(height, maxY - minY + 1 + margin * 2),
      area: points.length,
      points: points
    };
  }

  /**
   * ÂêàÂπ∂Áõ∏ËøëÂå∫ÂüüÔºàÂ¢ûÂº∫ÁâàÔºâ
   */
  mergeNearbyRegions(regions, threshold = 80) {
    if (regions.length <= 1) return regions;

    console.log(`Starting merge of ${regions.length} regions...`);

    // Step 1: Sort by region size, prioritize processing large regions
    const sortedRegions = regions.sort((a, b) => (b.width * b.height) - (a.width * a.height));
    
    const merged = [];
    const used = new Array(sortedRegions.length).fill(false);

    for (let i = 0; i < sortedRegions.length; i++) {
      if (used[i]) continue;

      const group = [sortedRegions[i]];
      used[i] = true;

      // Find nearby regions - use stricter merge conditions
      for (let j = i + 1; j < sortedRegions.length; j++) {
        if (used[j]) continue;

        if (this.shouldMergeRegions(sortedRegions[i], sortedRegions[j], threshold)) {
          group.push(sortedRegions[j]);
          used[j] = true;
        }
      }

      // Create merged region
      if (group.length === 1) {
        merged.push(group[0]);
      } else {
        console.log(`Merged ${group.length} small regions into one large region`);
        merged.push(this.createMergedRegion(group, merged.length + 1));
      }
    }

    // Step 2: Further remove overlapping regions
    const deduped = this.removeDuplicateRegions(merged);
    
    console.log(`Finally retained ${deduped.length} regions`);
    return deduped;
  }

  /**
   * Remove duplicate and highly overlapping regions
   */
  removeDuplicateRegions(regions) {
    if (regions.length <= 1) return regions;

    const filtered = [];
    
    for (let i = 0; i < regions.length; i++) {
      let isDuplicate = false;
      
      for (let j = 0; j < filtered.length; j++) {
        // Calculate overlap area
        const overlapArea = this.calculateOverlapArea(regions[i], filtered[j]);
        const region1Area = regions[i].width * regions[i].height;
        const region2Area = filtered[j].width * filtered[j].height;
        
        // If overlap exceeds 70%, consider as duplicate region
        const overlapRatio1 = overlapArea / region1Area;
        const overlapRatio2 = overlapArea / region2Area;
        
        if (overlapRatio1 > 0.7 || overlapRatio2 > 0.7) {
          isDuplicate = true;
          // Keep larger region
          if (region1Area > region2Area) {
            filtered[j] = regions[i];
          }
          break;
        }
      }
      
      if (!isDuplicate) {
        filtered.push(regions[i]);
      }
    }
    
    return filtered;
  }

  /**
   * ËÆ°ÁÆó‰∏§‰∏™Âå∫ÂüüÁöÑÈáçÂè†Èù¢ÁßØ
   */
  calculateOverlapArea(region1, region2) {
    const left = Math.max(region1.x, region2.x);
    const right = Math.min(region1.x + region1.width, region2.x + region2.width);
    const top = Math.max(region1.y, region2.y);
    const bottom = Math.min(region1.y + region1.height, region2.y + region2.height);
    
    if (left < right && top < bottom) {
      return (right - left) * (bottom - top);
    }
    
    return 0;
  }

  /**
   * Âà§Êñ≠ÊòØÂê¶Â∫îËØ•ÂêàÂπ∂Âå∫ÂüüÔºàÊõ¥‰∏•Ê†ºÁöÑÊù°‰ª∂Ôºâ
   */
  shouldMergeRegions(region1, region2, threshold) {
    const cx1 = region1.x + region1.width / 2;
    const cy1 = region1.y + region1.height / 2;
    const cx2 = region2.x + region2.width / 2;
    const cy2 = region2.y + region2.height / 2;

    const distance = Math.sqrt((cx1 - cx2)**2 + (cy1 - cy2)**2);
    
    // ËÆ°ÁÆóÂå∫ÂüüÂ∞∫ÂØ∏Â∑ÆÂºÇ
    const area1 = region1.width * region1.height;
    const area2 = region2.width * region2.height;
    const sizeRatio = Math.min(area1, area2) / Math.max(area1, area2);
    
    // ËÆ°ÁÆóÈáçÂè†Â∫¶
    const overlapArea = this.calculateOverlapArea(region1, region2);
    const overlapRatio = overlapArea / Math.min(area1, area2);
    
    // Êõ¥‰∏•Ê†ºÁöÑÂêàÂπ∂Êù°‰ª∂
    const shouldMerge = (
      // 1. Ë∑ùÁ¶ªÂæàËøë‰∏îÂ§ßÂ∞èÁõ∏‰ºº
      (distance < threshold * 0.8 && sizeRatio > 0.3) ||
      // 2. ÊúâÈáçÂè†‰∏îÂú®ÂêàÁêÜËåÉÂõ¥ÂÜÖ
      (overlapRatio > 0.1 && overlapRatio < 0.9) ||
      // 3. Ê∞¥Âπ≥ÊàñÂûÇÁõ¥ÂØπÈΩê‰∏îË∑ùÁ¶ªÈÄÇ‰∏≠
      (Math.abs(cy1 - cy2) < 25 && distance < threshold && sizeRatio > 0.2) ||
      (Math.abs(cx1 - cx2) < 25 && distance < threshold && sizeRatio > 0.2)
    );
    
    // ‰ΩÜ‰∏çË¶ÅÂêàÂπ∂Áõ∏Â∑ÆÂ§™Â§ßÁöÑÂå∫Âüü
    if (Math.max(area1, area2) / Math.min(area1, area2) > 10) {
      return false;
    }
    
    return shouldMerge;
  }

  /**
   * ÂàõÂª∫ÂêàÂπ∂Âå∫Âüü
   */
  createMergedRegion(regions, id) {
    const minX = Math.min(...regions.map(r => r.x));
    const minY = Math.min(...regions.map(r => r.y));
    const maxX = Math.max(...regions.map(r => r.x + r.width));
    const maxY = Math.max(...regions.map(r => r.y + r.height));

    return {
      id: id,
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY,
      area: regions.reduce((sum, r) => sum + r.area, 0),
      type: 'merged',
      subRegions: regions.length
    };
  }

  /**
   * UIÂÖÉÁ¥†ÂàÜÁ±ª
   */
  classifyUIElements(regions, canvas) {
    console.log('üéØ Starting UI element classification...');

    return regions.map(region => {
      const elementType = this.classifyByFeatures(
        region.width, 
        region.height, 
        region.x, 
        region.y, 
        canvas.width, 
        canvas.height
      );

      return {
        ...region,
        elementType: elementType,
        confidence: 0.85
      };
    });
  }

  /**
   * Ê†πÊçÆÁâπÂæÅÂàÜÁ±ªÂÖÉÁ¥†
   */
  classifyByFeatures(width, height, x, y, imgWidth, imgHeight) {
    const area = width * height;
    const aspectRatio = width / height;
    
    // ‰ΩçÁΩÆÂàÜÊûê
    const isTop = y < imgHeight * 0.2;
    const isCenter = y > imgHeight * 0.3 && y < imgHeight * 0.7;
    const isBottom = y > imgHeight * 0.8;

    // ÂàÜÁ±ªÈÄªËæë
    if (isTop && height < 60 && width > 200) {
      return 'header';
    } else if (height < 40 && width > 150 && aspectRatio > 3) {
      return 'text';
    } else if (60 <= width <= 200 && 25 <= height <= 60 && aspectRatio < 4) {
      return 'button';
    } else if (width < 80 && height < 80 && aspectRatio < 2) {
      return 'icon';
    } else if (width > 300 && height < 100) {
      return 'navigation';
    } else if (area > 8000) {
      return 'container';
    } else if (isBottom && height < 100) {
      return 'footer';
    } else {
      return 'element';
    }
  }

  /**
   * ÁîüÊàêÂå∫ÂüüÊà™Âõæ
   */
  async generateRegionScreenshots(regions, overlayCanvas) {
    console.log('üì∏ Generating region screenshots...');

    const screenshots = [];

    for (let i = 0; i < regions.length; i++) {
      const region = regions[i];
      
      // ÂàõÂª∫Âå∫ÂüüÊà™Âõæcanvas
      const regionCanvas = this.createCanvas(region.width, region.height);
      const regionCtx = regionCanvas.getContext('2d');
      
      // ‰ªéÂπ≤ÂáÄÁöÑÂè†Âä†Âõæ‰∏≠Ë£ÅÂâ™Âå∫ÂüüÔºàÂ∑≤Áªè‰∏çÂåÖÂê´Â∫èÂè∑Ôºâ
      regionCtx.drawImage(
        overlayCanvas,
        region.x, region.y, region.width, region.height,
        0, 0, region.width, region.height
      );

      // Âú®Âå∫ÂüüÊà™Âõæ‰∏äÁîªÁ∫¢Ëâ≤ËæπÊ°Ü
      regionCtx.strokeStyle = 'red';
      regionCtx.lineWidth = 3;
      regionCtx.strokeRect(0, 0, region.width, region.height);

      screenshots.push({
        regionId: region.id,
        elementType: region.elementType,
        canvas: regionCanvas,
        dataURL: regionCanvas.toDataURL('image/png'),
        bounds: {
          x: region.x,
          y: region.y,
          width: region.width,
          height: region.height
        },
        // Ê∑ªÂä†Â∑ÆÂºÇÂàÜÊûêÊï∞ÊçÆ
        diffAnalysis: {
          area: region.area,
          pixelCount: region.area,  // Â∑ÆÂºÇÂÉèÁ¥†Êï∞Èáè
          severity: this.calculateSeverity(region.area),
          aspectRatio: region.width / region.height,
          isLargeArea: region.area > 8000,
          isSmallIcon: region.width < 80 && region.height < 80,
          isWideElement: (region.width / region.height) > 3,
          isTallElement: (region.height / region.width) > 2
        }
      });
    }

    console.log(`Generated ${screenshots.length} region screenshots`);
    return screenshots;
  }

  /**
   * ÂàõÂª∫‰∏çÂ∏¶Â∫èÂè∑ÁöÑÂè†Âä†ÂõæÔºàÁî®‰∫éÊà™ÂõæÔºâ
   */
  createOverlayCanvasWithoutNumbers(designCanvas, webCanvas, regions) {
    const canvas = this.createCanvas(designCanvas.width, designCanvas.height);
    const ctx = canvas.getContext('2d');

    // ÂàõÂª∫ÂçäÈÄèÊòéÂè†Âä†
    ctx.globalAlpha = 0.5;
    ctx.drawImage(designCanvas, 0, 0);
    ctx.drawImage(webCanvas, 0, 0);
    ctx.globalAlpha = 1.0;

    // Âè™ÁîªÁ∫¢Ëâ≤ËæπÊ°ÜÔºå‰∏çÁîªÂ∫èÂè∑ÂúÜÂúà
    regions.forEach((region) => {
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 4;
      ctx.strokeRect(region.x, region.y, region.width, region.height);
    });

    return canvas;
  }



  /**
   * ÁîüÊàêÂü∫‰∫éÂÉèÁ¥†Â∑ÆÂºÇÁöÑÁ≤æÂáÜÈóÆÈ¢òÊèèËø∞
   */
  async generateProblemDescriptions(regionScreenshots) {
    console.log('üéØ Generating precise problem descriptions based on pixel differences...');

    const descriptions = [];

    for (const screenshot of regionScreenshots) {
      try {
        // Áõ¥Êé•Âü∫‰∫éÂå∫ÂüüÁâπÂæÅÂíåÂÉèÁ¥†Â∑ÆÂºÇÁîüÊàêÊèèËø∞
        const description = this.generatePreciseDescription(screenshot);
        
        descriptions.push({
          regionId: screenshot.regionId,
          description: description.title,
          suggestion: description.suggestion
        });

      } catch (error) {
        console.error(`Failed to generate description, using fallback solution:`, error);
        
        // Â§áÁî®ÊñπÊ°à
        const description = this.generateSmartDescription(screenshot);
        descriptions.push({
          regionId: screenshot.regionId,
          description: description.title,
          suggestion: description.suggestion
        });
      }
    }

    return descriptions;
  }

  /**
   * Ë∞ÉÁî®Hugging Face BLIP-2 APIÔºàÊ∞∏‰πÖÂÖçË¥πÔºâ
   */
  async callHuggingFaceAPI(screenshot) {
    try {
      console.log('üîó Calling Hugging Face BLIP-2 API...');
      
      // ÊûÑÈÄ†‰∏≠ÊñáUIËµ∞Êü•‰∏ìÁî®ÊèêÁ§∫ËØç
      const prompt = this.buildUIInspectionPrompt(screenshot.elementType);
      
      const response = await fetch('https://api-inference.huggingface.co/models/Salesforce/blip2-opt-2.7b', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          inputs: screenshot.dataURL,
          parameters: {
            text: prompt,
            max_new_tokens: 150,
            temperature: 0.7
          }
        })
      });

      if (!response.ok) {
        throw new Error(`API call failed: ${response.status} ${response.statusText}`);
      }

      const result = await response.json();
      console.log('‚úÖ Hugging Face API response:', result);

      // Ëß£ÊûêAPIËøîÂõûÁöÑÁªìÊûúÂπ∂Ê†ºÂºèÂåñ‰∏∫Êàë‰ª¨ÈúÄË¶ÅÁöÑÊ†ºÂºè
      return this.parseHuggingFaceResponse(result, screenshot);
      
    } catch (error) {
      console.error('Hugging Face API call failed:', error);
      throw error;
    }
  }

  /**
   * ÊûÑÈÄ†UIËµ∞Êü•‰∏ìÁî®ÊèêÁ§∫ËØç
   */
  buildUIInspectionPrompt(elementType) {
    const prompts = {
      'header': 'ÂàÜÊûêËøô‰∏™È°µÂ§¥Âå∫ÂüüÁöÑUIÈóÆÈ¢òÔºåÊ£ÄÊü•È´òÂ∫¶„ÄÅÂØπÈΩê„ÄÅÈó¥Ë∑ùÊòØÂê¶Á¨¶ÂêàËÆæËÆ°ËßÑËåÉ',
      'text': 'ÂàÜÊûêËøô‰∏™ÊñáÂ≠óÂå∫ÂüüÁöÑÈóÆÈ¢òÔºåÊ£ÄÊü•Â≠ó‰ΩìÂ§ßÂ∞è„ÄÅÈ¢úËâ≤„ÄÅË°åÈ´ò„ÄÅÂØπÈΩêÊñπÂºè',
      'button': 'ÂàÜÊûêËøô‰∏™ÊåâÈíÆÁöÑÊ†∑ÂºèÈóÆÈ¢òÔºåÊ£ÄÊü•Â∞∫ÂØ∏„ÄÅÂúÜËßí„ÄÅÈ¢úËâ≤„ÄÅÂÜÖËæπË∑ù',
      'icon': 'ÂàÜÊûêËøô‰∏™ÂõæÊ†áÁöÑÊòæÁ§∫ÈóÆÈ¢òÔºåÊ£ÄÊü•Â§ßÂ∞è„ÄÅÈ¢úËâ≤„ÄÅ‰ΩçÁΩÆ„ÄÅÂØπÈΩê',
      'navigation': 'ÂàÜÊûêËøô‰∏™ÂØºËà™Âå∫ÂüüÁöÑÂ∏ÉÂ±ÄÈóÆÈ¢òÔºåÊ£ÄÊü•Èó¥Ë∑ù„ÄÅÂØπÈΩê„ÄÅÂìçÂ∫îÂºèÊïàÊûú',
      'container': 'ÂàÜÊûêËøô‰∏™ÂÆπÂô®ÁöÑÂ∏ÉÂ±ÄÈóÆÈ¢òÔºåÊ£ÄÊü•ÂÆΩÂ∫¶„ÄÅÂÜÖËæπË∑ù„ÄÅËÉåÊôØ„ÄÅËæπÊ°Ü',
      'footer': 'ÂàÜÊûêËøô‰∏™È°µËÑöÂå∫ÂüüÁöÑÈóÆÈ¢òÔºåÊ£ÄÊü•È´òÂ∫¶„ÄÅÂÜÖÂÆπÂ∏ÉÂ±Ä„ÄÅÂØπÈΩêÊñπÂºè',
      'element': 'ÂàÜÊûêËøô‰∏™UIÂÖÉÁ¥†ÁöÑÈóÆÈ¢òÔºåÊ£ÄÊü•‰ΩçÁΩÆ„ÄÅÂ∞∫ÂØ∏„ÄÅÊ†∑ÂºèÊòØÂê¶Á¨¶ÂêàËÆæËÆ°Á®ø'
    };

    const basePrompt = prompts[elementType] || prompts['element'];
    return `ËøôÊòØ‰∏Ä‰∏™UIËµ∞Êü•Êà™ÂõæÔºåÊòæÁ§∫‰∫Ü‰∏Ä‰∏™${elementType}ÂÖÉÁ¥†„ÄÇ${basePrompt}„ÄÇËØ∑Áî®‰∏≠ÊñáÊèèËø∞ÂÖ∑‰ΩìÈóÆÈ¢òÂíå‰øÆÊîπÂª∫ËÆÆ„ÄÇ`;
  }

  /**
   * Ëß£ÊûêHugging Face APIÂìçÂ∫î
   */
  parseHuggingFaceResponse(apiResponse, screenshot) {
    try {
      // BLIP-2ËøîÂõûÁöÑÊñáÊú¨ÊèèËø∞
      let description = '';
      if (Array.isArray(apiResponse)) {
        description = apiResponse[0]?.generated_text || '';
      } else if (apiResponse.generated_text) {
        description = apiResponse.generated_text;
      } else {
        throw new Error('APIËøîÂõûÊ†ºÂºè‰∏çÊ≠£Á°Æ');
      }

      // Âü∫‰∫éAPIÊèèËø∞ÂíåÂÖÉÁ¥†Á±ªÂûãÁîüÊàêÂÖ∑‰ΩìÁöÑÈóÆÈ¢òÊèèËø∞ÂíåÂª∫ËÆÆ
      return this.generateUISpecificDescription(description, screenshot);
      
    } catch (error) {
      console.error('Ëß£ÊûêAPIÂìçÂ∫îÂ§±Ë¥•:', error);
      // Ëß£ÊûêÂ§±Ë¥•Êó∂‰ΩøÁî®Êô∫ËÉΩÂ§áÁî®ÊñπÊ°à
      return this.generateSmartDescription(screenshot);
    }
  }

  /**
   * ÁîüÊàêÂü∫‰∫éÂÆûÈôÖÂ∑ÆÂºÇÁöÑÁ≤æÂáÜÊèèËø∞
   */
  generatePreciseDescription(screenshot) {
    const elementType = screenshot.elementType;
    const bounds = screenshot.bounds;
    const diff = screenshot.diffAnalysis || {};
    
    // Âü∫‰∫éÂå∫Âüü‰ΩçÁΩÆÂà§Êñ≠È°µÈù¢Âå∫Âüü
    const position = this.getPagePosition(bounds);
    
    // Â∑ÆÂºÇ‰∏•ÈáçÁ®ãÂ∫¶
    const severity = diff.severity || 'minor';
    const severityText = severity === 'critical' ? 'significant' : severity === 'medium' ? 'obvious' : 'minor';
    
    // Âü∫‰∫éÂÖÉÁ¥†Á±ªÂûã„ÄÅÂ∑ÆÂºÇÁâπÂæÅÂíåÂÆûÈôÖÂ∞∫ÂØ∏ÁîüÊàêÂáÜÁ°ÆÊèèËø∞
    let title = '';
    let suggestion = '';
    
    switch (elementType) {
      case 'text':
        if (diff.isWideElement) {
          title = `Long text area in ${position} has ${severityText} differences from design mockup, may involve line breaks, alignment or letter spacing issues`;
          suggestion = `Check text-align alignment, adjust letter-spacing and word-spacing, ensure text width is controlled within ${Math.round(bounds.width * 0.9)}px`;
        } else {
          title = `Text area in ${position} has ${severityText} differences from design mockup, font size or line height may be inconsistent`;
          suggestion = `Recommend adjusting font-size to ${Math.max(12, Math.round(bounds.height * 0.8))}px, line-height to ${(bounds.height * 1.2).toFixed(1)}px`;
        }
        break;
        
      case 'button':
        if (diff.isWideElement) {
          title = `Wide button style in ${position} has ${severityText} differences from design mockup, aspect ratio is uncoordinated`;
          suggestion = `Adjust button max-width to ${Math.round(bounds.width * 0.75)}px, increase vertical padding to improve proportion`;
        } else if (diff.isSmallIcon) {
          title = `Small button size in ${position} does not match design mockup, may be too small or lack padding`;
          suggestion = `Increase button minimum size to 32√ó32px, set padding: 8px 12px`;
        } else {
          title = `Button style in ${position} has ${severityText} differences from design mockup, need to adjust size or border radius`;
          suggestion = `Set button width to ${bounds.width}px, height to ${bounds.height}px, border-radius: ${Math.min(bounds.height/4, 8)}px`;
        }
        break;
        
      case 'icon':
        if (diff.isSmallIcon) {
          title = `Small icon display in ${position} has ${severityText} differences from design mockup, may be too small or unclear`;
          suggestion = `Ensure icon minimum size is 24√ó24px, use SVG format for clarity`;
        } else {
          title = `Icon size in ${position} does not match design mockup, displays too large or deformed`;
          suggestion = `Adjust icon size to ${Math.min(bounds.width, bounds.height)}√ó${Math.min(bounds.width, bounds.height)}px, maintain square proportion`;
        }
        break;
        
      case 'header':
        title = `Header area layout in ${position} has ${severityText} differences from design mockup, overall height or content distribution needs adjustment`;
        suggestion = `Set header fixed height to ${bounds.height}px, use flexbox to ensure content vertical center alignment`;
        break;
        
      case 'navigation':
        if (diff.isWideElement) {
          title = `Navigation bar width in ${position} has ${severityText} differences from design mockup, may have filled entire container width`;
          suggestion = `Limit navigation container max-width, increase gap between navigation items to ${Math.round(bounds.width * 0.03)}px`;
        } else {
          title = `Navigation area spacing or alignment in ${position} does not match design mockup`;
          suggestion = `Adjust navigation item spacing to 16px, ensure horizontal center alignment`;
        }
        break;
        
      case 'container':
        if (diff.isLargeArea) {
          title = `Large container area in ${position} has ${severityText} differences from design mockup, overall layout structure has major deviation`;
          suggestion = `Re-check container max-width limit, recommend setting to 1200px, adjust internal element spacing`;
        } else {
          title = `Container element in ${position} has ${severityText} differences from design mockup, margins or content arrangement needs optimization`;
          suggestion = `Adjust container padding to 16px, margin to auto for centering`;
        }
        break;
        
      case 'footer':
        title = `Footer area height or content layout in ${position} has ${severityText} differences from design mockup`;
        suggestion = `Set footer minimum height to ${Math.max(60, bounds.height)}px, use flexbox layout to ensure content centering`;
        break;
        
      default:
        if (diff.isLargeArea) {
          title = `Large area in ${position} has ${severityText} visual differences from design mockup, may involve background or layout issues`;
          suggestion = `Check background-color, border and overall layout settings in this area`;
        } else if (diff.isSmallIcon) {
          title = `Small element in ${position} displays inconsistently with design mockup, may be too small or missing`;
          suggestion = `Ensure element minimum display size, check visibility and opacity properties`;
        } else {
          title = `UI element in ${position} has ${severityText} visual differences from design mockup`;
          suggestion = `Check position, size and style property settings of this element against design mockup`;
        }
    }
    
    return { title, suggestion };
  }

  /**
   * Ëé∑ÂèñÈ°µÈù¢‰ΩçÁΩÆÊèèËø∞
   */
  getPagePosition(bounds) {
    const centerY = bounds.y + bounds.height / 2;
    const centerX = bounds.x + bounds.width / 2;
    
    let position = '';
    
    if (centerY < 150) {
      position = 'page top';
    } else if (centerY > 600) {
      position = 'page bottom';
    } else if (centerY > 200 && centerY < 500) {
      if (centerX < 300) {
        position = 'page middle-left';
      } else if (centerX > 700) {
        position = 'page middle-right';
      } else {
        position = 'page center area';
      }
    } else {
      position = 'page middle-upper';
    }
    
    return position;
  }

  /**
   * Âü∫‰∫éAPIÊèèËø∞ÁîüÊàêUIÁâπÂÆöÈóÆÈ¢òÊèèËø∞ÂíåÂª∫ËÆÆÔºà‰øùÁïô‰ΩúÂ§áÁî®Ôºâ
   */
  generateUISpecificDescription(apiDescription, screenshot) {
    const elementType = screenshot.elementType;
    const bounds = screenshot.bounds;
    
    // ÂàÜÊûêAPIÊèèËø∞‰∏≠ÁöÑÂÖ≥ÈîÆ‰ø°ÊÅØ
    const hasColorIssue = /color|È¢úËâ≤|Ëâ≤ÂΩ©/.test(apiDescription);
    const hasSizeIssue = /size|Â§ßÂ∞è|Â∞∫ÂØ∏/.test(apiDescription);
    const hasPositionIssue = /position|‰ΩçÁΩÆ|ÂØπÈΩê/.test(apiDescription);
    const hasSpacingIssue = /spacing|Èó¥Ë∑ù|padding|margin/.test(apiDescription);
    
    // Ê†πÊçÆÂÖÉÁ¥†Á±ªÂûãÂíåAPIÂàÜÊûêÁªìÊûúÁîüÊàêÂÖ∑‰ΩìÊèèËø∞
    let title = '';
    let suggestion = '';
    
    switch (elementType) {
      case 'text':
        if (hasColorIssue && hasSizeIssue) {
          title = `ÊñáÂ≠óÂå∫ÂüüÁöÑÈ¢úËâ≤ÂíåÂ≠ó‰ΩìÂ§ßÂ∞è‰∏éËÆæËÆ°Á®ø‰∏ç‰∏ÄËá¥Ôºå${apiDescription.substring(0, 50)}...`;
          suggestion = `Ë∞ÉÊï¥ÊñáÂ≠óÈ¢úËâ≤ÂÄºÂíåÂ≠ó‰ΩìÂ§ßÂ∞èÔºåÂª∫ËÆÆfont-size: ${Math.max(14, bounds.height * 0.6)}px`;
        } else if (hasColorIssue) {
          title = `ÊñáÂ≠óÈ¢úËâ≤‰∏éËÆæËÆ°Á®øÂ≠òÂú®Â∑ÆÂºÇÔºåÊòæÁ§∫ÊïàÊûú‰∏çÁ¨¶ÂêàÈ¢ÑÊúü`;
          suggestion = `Ê£ÄÊü•Âπ∂‰øÆÊîπÊñáÂ≠ócolorÂ±ûÊÄßÔºåÁ°Æ‰øù‰∏éËÆæËÆ°Á®øÈ¢úËâ≤ÂÄº‰∏ÄËá¥`;
        } else {
          title = `ÊñáÂ≠óÊ†∑Âºè‰∏éËÆæËÆ°Á®ø‰∏çÂåπÈÖçÔºåÂèØËÉΩÊ∂âÂèäÂ≠ó‰Ωì„ÄÅÂ§ßÂ∞èÊàñË°åÈ´ò`;
          suggestion = `Ë∞ÉÊï¥font-size‰∏∫${Math.max(14, bounds.height * 0.6)}pxÔºåline-height‰∏∫${(bounds.height * 0.8).toFixed(1)}px`;
        }
        break;
        
      case 'button':
        if (hasColorIssue) {
          title = `ÊåâÈíÆËÉåÊôØËâ≤ÊàñËæπÊ°ÜÈ¢úËâ≤‰∏éËÆæËÆ°Á®ø‰∏çÁ¨¶ÔºåÂΩ±ÂìçËßÜËßâÁªü‰∏ÄÊÄß`;
          suggestion = `‰øÆÊîπÊåâÈíÆÁöÑbackground-colorÂíåborder-colorÔºåÁ°Æ‰øù‰∏éËÆæËÆ°Á®øÈ¢úËâ≤‰∏ÄËá¥`;
        } else if (hasSizeIssue) {
          title = `ÊåâÈíÆÂ∞∫ÂØ∏‰∏éËÆæËÆ°Á®øÂ∑ÆÂºÇÊòéÊòæÔºåÈúÄË¶ÅË∞ÉÊï¥ÂÆΩÈ´ò`;
          suggestion = `ËÆæÁΩÆÊåâÈíÆÂ∞∫ÂØ∏‰∏∫${bounds.width}√ó${bounds.height}pxÔºåË∞ÉÊï¥ÂÜÖËæπË∑ù`;
        } else {
          title = `ÊåâÈíÆÊ†∑Âºè‰∏éËÆæËÆ°Á®øÂ≠òÂú®Â∑ÆÂºÇÔºåÈúÄË¶Å‰ºòÂåñËßÜËßâÊïàÊûú`;
          suggestion = `Ë∞ÉÊï¥padding: ${Math.round(bounds.height * 0.25)}px ${Math.round(bounds.width * 0.1)}pxÔºåborder-radius: ${Math.min(bounds.height * 0.2, 8)}px`;
        }
        break;
        
      case 'icon':
        if (hasSizeIssue) {
          title = `ÂõæÊ†áÂ∞∫ÂØ∏‰∏éËÆæËÆ°Á®ø‰∏çÂåπÈÖçÔºåÊòæÁ§∫ËøáÂ§ßÊàñËøáÂ∞è`;
          suggestion = `Áªü‰∏ÄÂõæÊ†áÂ∞∫ÂØ∏‰∏∫${Math.max(24, Math.min(bounds.width, bounds.height))}px`;
        } else if (hasColorIssue) {
          title = `ÂõæÊ†áÈ¢úËâ≤ÊàñÈÄèÊòéÂ∫¶‰∏éËÆæËÆ°Á®ø‰∏ç‰∏ÄËá¥`;
          suggestion = `Ê£ÄÊü•ÂõæÊ†áÁöÑfillÊàñcolorÂ±ûÊÄßÔºåÁ°Æ‰øùÈ¢úËâ≤ÂÄº‰∏éËÆæËÆ°Á®øÁõ∏Á¨¶`;
        } else {
          title = `ÂõæÊ†áÊòæÁ§∫‰∏éËÆæËÆ°Á®øÂ≠òÂú®Â∑ÆÂºÇÔºåÈúÄË¶ÅË∞ÉÊï¥Ê†∑Âºè`;
          suggestion = `Ê£ÄÊü•ÂõæÊ†áÁöÑÂ∞∫ÂØ∏„ÄÅÈ¢úËâ≤Âíå‰ΩçÁΩÆÔºåÁ°Æ‰øù‰∏éËÆæËÆ°Á®ø‰∏ÄËá¥`;
        }
        break;
        
      default:
        // ÈÄöÁî®Â§ÑÁêÜ
        if (hasColorIssue) {
          title = `${elementType}ÂÖÉÁ¥†ÁöÑÈ¢úËâ≤‰∏éËÆæËÆ°Á®ø‰∏çÁ¨¶ÔºåÈúÄË¶ÅË∞ÉÊï¥`;
          suggestion = `Ê£ÄÊü•ÂÖÉÁ¥†ÁöÑÈ¢úËâ≤Áõ∏ÂÖ≥CSSÂ±ûÊÄßÔºåÁ°Æ‰øù‰∏éËÆæËÆ°Á®øÈ¢úËâ≤ÂÄº‰∏ÄËá¥`;
        } else if (hasSizeIssue) {
          title = `${elementType}ÂÖÉÁ¥†Â∞∫ÂØ∏‰∏éËÆæËÆ°Á®øÂ∑ÆÂºÇËæÉÂ§ß`;
          suggestion = `Ë∞ÉÊï¥ÂÖÉÁ¥†Â∞∫ÂØ∏‰∏∫${bounds.width}√ó${bounds.height}pxÈôÑËøëÁöÑÂêàÈÄÇÂÄº`;
        } else {
          title = `${elementType}ÂÖÉÁ¥†‰∏éËÆæËÆ°Á®øÂ≠òÂú®ËßÜËßâÂ∑ÆÂºÇ`;
          suggestion = `ÂØπÁÖßËÆæËÆ°Á®øÊ£ÄÊü•ËØ•ÂÖÉÁ¥†ÁöÑÊ†∑ÂºèÂ±ûÊÄßÔºåËøõË°åÁõ∏Â∫îË∞ÉÊï¥`;
        }
    }
    
    return { title, suggestion };
  }

  /**
   * Êô∫ËÉΩÊèèËø∞ÁîüÊàêÔºàÂ§áÁî®ÊñπÊ°àÔºâ
   */
  generateSmartDescription(screenshot) {
    const elementType = screenshot.elementType;
    const bounds = screenshot.bounds;

    const descriptions = {
      'header': {
        title: 'Page header layout differs from design mockup, possibly inconsistent height or content arrangement',
        suggestion: `Adjust header container height to ${bounds.height}px, check content vertical center alignment`
      },
      'text': {
        title: 'Text content style does not match design mockup, font size or line height may be off',
        suggestion: `Recommend adjusting font-size to ${Math.max(14, bounds.height * 0.6)}px, line-height to ${(bounds.height * 0.8).toFixed(1)}px`
      },
      'button': {
        title: 'Button styling has significant differences from design mockup, need to adjust size, color or border radius',
        suggestion: `Set padding: ${Math.round(bounds.height * 0.25)}px ${Math.round(bounds.width * 0.1)}px, border-radius: ${Math.min(bounds.height * 0.2, 8)}px`
      },
      'icon': {
        title: 'Icon display does not match design mockup, possible size, color or position deviation',
        suggestion: `Unify icon size to ${Math.max(24, Math.min(bounds.width, bounds.height))}px, check if color values match design mockup`
      },
      'navigation': {
        title: 'Navigation elements layout inconsistent with design mockup, spacing or alignment needs adjustment',
        suggestion: `Check navigation item spacing, recommend setting margin: 0 ${Math.round(bounds.width * 0.02)}px`
      },
      'container': {
        title: 'Page middle-right large container area has significant differences from design mockup, overall layout structure has major deviation',
        suggestion: `Re-check container max-width: ${bounds.width}px, padding: ${Math.round(bounds.height * 0.03)}px`
      },
      'footer': {
        title: 'Footer area does not match design mockup, height or content layout needs adjustment',
        suggestion: `Adjust footer height to ${bounds.height}px, check content center alignment`
      },
      'element': {
        title: 'Page bottom button style differs from design mockup, need to adjust size or border radius',
        suggestion: `Refer to design mockup to adjust this element CSS properties, ensure accurate position and size`
      }
    };

    return descriptions[elementType] || descriptions['element'];
  }

  /**
   * Â§áÁî®ÊèèËø∞
   */
  getFallbackDescription(elementType) {
    return `${elementType} element differs from design mockup, needs further adjustment`;
  }

  getFallbackSuggestion(elementType) {
    return `Please check the style settings of this ${elementType} against design mockup`;
  }

  /**
   * Ê†ºÂºèÂåñ‰∏∫‰∫ßÂìÅÈóÆÈ¢òÂàóË°®Ê†ºÂºè
   */
  formatToProblemList(regions, screenshots, descriptions) {
    console.log('üìã Formatting problem list...');

    return regions.map((region, index) => {
      const screenshot = screenshots.find(s => s.regionId === region.id);
      const description = descriptions.find(d => d.regionId === region.id);

      return {
        x: region.x,
        y: region.y,
        width: region.width,
        height: region.height,
        description: description ? description.description : this.getFallbackDescription(region.elementType),
        suggestion: description ? description.suggestion : this.getFallbackSuggestion(region.elementType),
        elementType: region.elementType,
        confidence: region.confidence,
        screenshot: screenshot ? screenshot.dataURL : null,
        area: region.area,
        severity: this.calculateSeverity(region.area)
      };
    });
  }

  /**
   * ËÆ°ÁÆóÈóÆÈ¢ò‰∏•ÈáçÁ®ãÂ∫¶
   */
  calculateSeverity(area) {
    if (area > 8000) return 'critical';
    if (area > 2000) return 'medium';
    return 'minor';
  }

  /**
   * ËÆ°ÁÆóÁõ∏‰ººÂ∫¶
   */
  calculateSimilarity(diffMap) {
    const totalPixels = diffMap.length;
    const diffPixels = diffMap.filter(pixel => pixel > 0).length;
    return 1 - (diffPixels / totalPixels);
  }

  /**
   * ÂàõÂª∫Âè†Âä†Âõæcanvas
   */
  createOverlayCanvas(designCanvas, webCanvas, regions) {
    const canvas = this.createCanvas(designCanvas.width, designCanvas.height);
    const ctx = canvas.getContext('2d');

    // ÂàõÂª∫ÂçäÈÄèÊòéÂè†Âä†
    ctx.globalAlpha = 0.5;
    ctx.drawImage(designCanvas, 0, 0);
    ctx.drawImage(webCanvas, 0, 0);
    ctx.globalAlpha = 1.0;

    // ÁîªÁ∫¢Ëâ≤ËæπÊ°Ü
    regions.forEach((region, index) => {
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 4;
      ctx.strokeRect(region.x, region.y, region.width, region.height);

      // ÁîªÁºñÂè∑ÂúÜÂúà
      const centerX = region.x + 15;
      const centerY = region.y + 15;
      
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 12, 0, 2 * Math.PI);
      ctx.fill();

      ctx.fillStyle = 'white';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText((index + 1).toString(), centerX, centerY);
    });

    return canvas;
  }

  // === ËæÖÂä©ÊñπÊ≥ï ===

  createCanvas(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }

  loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }
}

// ÂØºÂá∫AIËµ∞Êü•Âô®
window.AIInspector = AIInspector;
