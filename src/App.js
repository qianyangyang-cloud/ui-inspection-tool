import React, { useState, useRef, useCallback } from 'react';
import html2canvas from 'html2canvas';
import './index.css';

function App() {
  const [url, setUrl] = useState('');
  const [currentUrl, setCurrentUrl] = useState('');
  const [designImage, setDesignImage] = useState(null);
  const [imageOpacity, setImageOpacity] = useState(0.5);
  const [imageSize, setImageSize] = useState({ width: 400, height: 300 });
  const [imagePosition, setImagePosition] = useState({ x: 0, y: 0 });
  const [imageScale, setImageScale] = useState(1);
  const [imageTransformOrigin, setImageTransformOrigin] = useState('center center');
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
  const [dragStart, setDragStart] = useState(null);
  const [resizeStart, setResizeStart] = useState(null);
  const [isSelecting, setIsSelecting] = useState(false);
  const [selection, setSelection] = useState(null);
  const [selectionStart, setSelectionStart] = useState(null);
  const [issues, setIssues] = useState([]);
  const [showModal, setShowModal] = useState(false);
  const [modalScreenshot, setModalScreenshot] = useState(null);
  const [currentIssue, setCurrentIssue] = useState({ description: '', suggestion: '' });
  const [editingIssueId, setEditingIssueId] = useState(null);
  const [designSize, setDesignSize] = useState({ width: 1440, height: 900 });
  const [showScreenshotTip, setShowScreenshotTip] = useState(false);
  const [showAIModal, setShowAIModal] = useState(false);
  const [showVideoTutorial, setShowVideoTutorial] = useState(false);
  const [aiUploadedImages, setAiUploadedImages] = useState([]);
  const [isAIProcessing, setIsAIProcessing] = useState(false);
  const [aiProgress, setAiProgress] = useState({ step: '', progress: 0 });
  const [enlargedImage, setEnlargedImage] = useState(null);
  const [showNoDiffToast, setShowNoDiffToast] = useState(false);
  
  // Batch selection related states
  const [selectedIssues, setSelectedIssues] = useState(new Set());
  const [isMultiSelectMode, setIsMultiSelectMode] = useState(false);
  
  // Multi-page inspection related states
  const [pageInspections, setPageInspections] = useState([]); // All page inspection records
  const [currentPageInfo, setCurrentPageInfo] = useState(null); // Current page information
  const [autoScreenshotEnabled, setAutoScreenshotEnabled] = useState(false); // Auto screenshot toggle
  const [pageChangeDetected, setPageChangeDetected] = useState(false); // Page change detection
  const [isMultiPageMode, setIsMultiPageMode] = useState(false); // Multi-page mode
  const [pageScreenshots, setPageScreenshots] = useState({}); // Page screenshot cache
  const [designImageMatching, setDesignImageMatching] = useState({}); // Design image matching results
  const [showPagePanel, setShowPagePanel] = useState(true); // Show multi-page info panel

  const previewRef = useRef();
  const fileInputRef = useRef();
  const iframeRef = useRef();
  const pageMonitorIntervalRef = useRef(null);
  const iframeObserverRef = useRef(null);
  const lastScreenshotTimeRef = useRef(0);

  // Enhanced page info detection and recognition
  const detectPageInfo = async () => {
    if (!iframeRef.current || !iframeRef.current.contentWindow) {
      console.log('üö´ iframe or contentWindow does not exist');
      return null;
    }

    try {
      const iframe = iframeRef.current;
      const iframeDoc = iframe.contentWindow.document;
      
      // Get basic page information
      const url = iframe.contentWindow.location.href;
      const title = iframeDoc.title || 'No Title';
      const pathname = iframe.contentWindow.location.pathname;
      const hash = iframe.contentWindow.location.hash;
      const search = iframe.contentWindow.location.search;
      
      console.log('üìÑ Detecting page info:', {
        url,
        title,
        pathname,
        hash,
        search
      });
      
      // Generate unique page identifier (more precise)
      const pageKey = `${pathname}${hash}${search}`;
      
      // Detect page content fingerprint (for SPA route changes)
      const contentFingerprint = generateContentFingerprint(iframeDoc);
      
      // Detect page features for design image matching
      const bodyClasses = Array.from(iframeDoc.body?.classList || []);
      const mainHeading = iframeDoc.querySelector('h1')?.textContent || 
                         iframeDoc.querySelector('h2')?.textContent || 
                         iframeDoc.querySelector('.title')?.textContent || 
                         iframeDoc.querySelector('h3')?.textContent || '';
      const pageDescription = iframeDoc.querySelector('meta[name="description"]')?.content || '';
      
      // More intelligent page type detection
      const pageType = detectPageType(url, title, mainHeading, bodyClasses, iframeDoc);
      
      const pageInfo = {
        url,
        title,
        pathname,
        hash,
        search,
        pageKey,
        contentFingerprint,
        pageType,
        bodyClasses,
        mainHeading,
        pageDescription,
        timestamp: Date.now()
      };
      
      console.log('‚úÖ Page info detection successful:', pageInfo);
      return pageInfo;
      
    } catch (error) {
      console.warn('‚ö†Ô∏è Unable to detect page info, possibly due to cross-origin restrictions:', error);
      // Fallback detection for cross-origin situations
      return detectPageInfoFallback();
    }
  };

  // Generate page content fingerprint
  const generateContentFingerprint = (doc) => {
    try {
      // Get main content elements - expand detection scope
      const headings = Array.from(doc.querySelectorAll('h1, h2, h3, h4, h5, h6')).map(h => h.textContent?.trim()).filter(Boolean);
      const navItems = Array.from(doc.querySelectorAll('nav a, .nav a, .navigation a, .menu a, header a')).map(a => a.textContent?.trim()).filter(Boolean);
      const buttons = Array.from(doc.querySelectorAll('button, .button, .btn')).map(b => b.textContent?.trim()).filter(Boolean);
      
      // Get text from main content areas
      const contentSelectors = ['main', '.main', '.content', '.container', 'article', '.article', 'section'];
      let mainContent = '';
      for (const selector of contentSelectors) {
        const element = doc.querySelector(selector);
        if (element) {
          mainContent = element.textContent?.substring(0, 300) || '';
          break;
        }
      }
      
      // If no main content area found, use partial body content
      if (!mainContent) {
        mainContent = doc.body?.textContent?.substring(0, 300) || '';
      }
      
      // Get first 200 characters of all visible text as features
      const allText = doc.body?.innerText?.replace(/\s+/g, ' ').trim().substring(0, 200) || '';
      
      // Generate more sensitive content fingerprint
      const fingerprint = {
        headings: headings.slice(0, 5),
        navItems: navItems.slice(0, 8),
        buttons: buttons.slice(0, 5),
        contentPreview: mainContent.replace(/\s+/g, ' ').trim(),
        textPreview: allText,
        elementCount: {
          divs: doc.querySelectorAll('div').length,
          buttons: doc.querySelectorAll('button, .button, .btn').length,
          links: doc.querySelectorAll('a').length,
          images: doc.querySelectorAll('img').length,
          headings: headings.length
        },
        // Add page structure features
        hasHeader: !!doc.querySelector('header, .header'),
        hasNav: !!doc.querySelector('nav, .nav, .navigation'),
        hasFooter: !!doc.querySelector('footer, .footer'),
        hasMain: !!doc.querySelector('main, .main')
      };
      
      const result = JSON.stringify(fingerprint);
      console.log('üìã Generated content fingerprint:', {
        headingsCount: headings.length,
        navItemsCount: navItems.length,
        contentLength: mainContent.length,
        fingerprintLength: result.length
      });
      
      return result;
    } catch (error) {
      console.warn('‚ö†Ô∏è ÁîüÊàêÂÜÖÂÆπÊåáÁ∫πÂ§±Ë¥•:', error);
      return Date.now().toString();
    }
  };

  // Êô∫ËÉΩÈ°µÈù¢Á±ªÂûãÊ£ÄÊµã
  const detectPageType = (url, title, mainHeading, bodyClasses, doc) => {
    const urlLower = url.toLowerCase();
    const titleLower = title.toLowerCase();
    const headingLower = mainHeading.toLowerCase();
    const classesStr = bodyClasses.join(' ').toLowerCase();
    
    // Ê£ÄÊµãÂÖ≥ÈîÆËØç
    if (urlLower.includes('login') || titleLower.includes('login') || headingLower.includes('login') || 
        classesStr.includes('login') || doc.querySelector('form[action*="login"]')) {
      return 'login';
    }
    if (urlLower.includes('register') || urlLower.includes('signup') || titleLower.includes('register') || 
        titleLower.includes('sign up') || headingLower.includes('register') || headingLower.includes('sign up')) {
      return 'register';
    }
    if (urlLower.includes('dashboard') || titleLower.includes('dashboard') || headingLower.includes('dashboard') || 
        classesStr.includes('dashboard')) {
      return 'dashboard';
    }
    if (urlLower.includes('profile') || urlLower.includes('account') || titleLower.includes('profile') || 
        titleLower.includes('account') || headingLower.includes('profile')) {
      return 'profile';
    }
    if (urlLower.includes('settings') || urlLower.includes('config') || titleLower.includes('settings') || 
        headingLower.includes('settings')) {
      return 'settings';
    }
    if (urlLower.includes('about') || titleLower.includes('about') || headingLower.includes('about')) {
      return 'about';
    }
    if (urlLower.includes('contact') || titleLower.includes('contact') || headingLower.includes('contact')) {
      return 'contact';
    }
    if (urlLower.includes('help') || urlLower.includes('support') || titleLower.includes('help') || 
        titleLower.includes('support') || headingLower.includes('help')) {
      return 'help';
    }
    if (headingLower.includes('ÂäüËÉΩ‰ªãÁªç') || headingLower.includes('features') || 
        titleLower.includes('ÂäüËÉΩ') || titleLower.includes('features')) {
      return 'features';
    }
    if (url.endsWith('/') || url.includes('/home') || titleLower.includes('home') || 
        titleLower.includes('È¶ñÈ°µ') || headingLower.includes('welcome')) {
      return 'home';
    }
    
    return 'page';
  };

  // Ë∑®ÂüüÊÉÖÂÜµ‰∏ãÁöÑÂ§áÁî®Ê£ÄÊµãÊñπÊ°à
  const detectPageInfoFallback = () => {
    if (!iframeRef.current) return null;
    
    try {
      // Â∞ùËØï‰ªé iframe ÁöÑ src Ëé∑Âèñ‰ø°ÊÅØ
      const iframeSrc = iframeRef.current.src;
      const url = new URL(iframeSrc);
      
      return {
        url: iframeSrc,
        title: `Page - ${url.pathname}`,
        pathname: url.pathname,
        hash: url.hash,
        search: url.search,
        pageKey: `${url.pathname}${url.hash}${url.search}`,
        contentFingerprint: Date.now().toString(),
        pageType: 'page',
        bodyClasses: [],
        mainHeading: '',
        pageDescription: '',
        timestamp: Date.now(),
        isCrossDomain: true
      };
    } catch (error) {
      console.warn('Â§áÁî®Ê£ÄÊµã‰πüÂ§±Ë¥•:', error);
      return null;
    }
  };

  // Â¢ûÂº∫ÁöÑÈ°µÈù¢ÂàáÊç¢ÁõëÂê¨
  const startPageMonitoring = () => {
    if (pageMonitorIntervalRef.current) {
      clearInterval(pageMonitorIntervalRef.current);
    }

    console.log('=== ÂºÄÂßãÈ°µÈù¢ÁõëÂê¨ ===');

    pageMonitorIntervalRef.current = setInterval(async () => {
      try {
        const newPageInfo = await detectPageInfo();
        
        if (newPageInfo && currentPageInfo) {
          // Ê£ÄÊµãÂ§öÁßçÁ±ªÂûãÁöÑÈ°µÈù¢ÂàáÊç¢
          const hasPageChanged = (
            newPageInfo.pageKey !== currentPageInfo.pageKey ||
            newPageInfo.contentFingerprint !== currentPageInfo.contentFingerprint ||
            newPageInfo.title !== currentPageInfo.title
          );
          
          if (hasPageChanged) {
            console.log('üîÑ Ê£ÄÊµãÂà∞È°µÈù¢ÂàáÊç¢:');
            console.log('ÊóßÈ°µÈù¢:', {
              key: currentPageInfo.pageKey,
              title: currentPageInfo.title,
              url: currentPageInfo.url
            });
            console.log('Êñ∞È°µÈù¢:', {
              key: newPageInfo.pageKey,
              title: newPageInfo.title,
              url: newPageInfo.url
            });
            
            setPageChangeDetected(true);
            
            // Êõ¥Êñ∞ÂΩìÂâçÈ°µÈù¢‰ø°ÊÅØ
            setCurrentPageInfo(newPageInfo);
            
            // Â¶ÇÊûúÂêØÁî®‰∫ÜËá™Âä®Êà™ÂõæÔºåÂàôËá™Âä®Êà™Âõæ
            if (autoScreenshotEnabled && isMultiPageMode) {
              console.log('‚è∞ Â∞ÜÂú® 2 ÁßíÂêéËá™Âä®Êà™Âõæ...');
              setTimeout(() => {
                handleAutoScreenshot(newPageInfo);
              }, 2000); // ÂáèÂ∞ëÂà∞2ÁßíÔºåÊèêÈ´òÂìçÂ∫îÈÄüÂ∫¶
            }
            
            // 3ÁßíÂêéÈöêËóèÈ°µÈù¢ÂàáÊç¢ÊèêÁ§∫
            setTimeout(() => {
              setPageChangeDetected(false);
            }, 3000);
          }
        } else if (newPageInfo && !currentPageInfo) {
          // ÂàùÂßãÂåñÈ°µÈù¢‰ø°ÊÅØ
          console.log('üéØ ÂàùÂßãÂåñÈ°µÈù¢‰ø°ÊÅØ:', newPageInfo.title);
          setCurrentPageInfo(newPageInfo);
          
          // Â¶ÇÊûúÂ∑≤ÁªèÂêØÁî®Â§öÈ°µÈù¢Ê®°ÂºèÔºå‰∏∫ÂàùÂßãÈ°µÈù¢‰πüÊà™Âõæ
          if (autoScreenshotEnabled && isMultiPageMode) {
            console.log('üì∑ ‰∏∫ÂàùÂßãÈ°µÈù¢Êà™Âõæ...');
            setTimeout(() => {
              handleAutoScreenshot(newPageInfo);
            }, 1000);
          }
        }
      } catch (error) {
        console.error('È°µÈù¢ÁõëÂê¨Âá∫Èîô:', error);
      }
    }, 500); // ÊèêÈ´òÊ£ÄÊµãÈ¢ëÁéáÂà∞500msÔºåÊõ¥Âø´ÈÄüÂìçÂ∫î
  };

  // ÂÅúÊ≠¢È°µÈù¢ÁõëÂê¨
  const stopPageMonitoring = () => {
    if (pageMonitorIntervalRef.current) {
      clearInterval(pageMonitorIntervalRef.current);
      pageMonitorIntervalRef.current = null;
    }
    
    // ÂÅúÊ≠¢iframeÂÜÖÂÆπËßÇÂØü
    if (iframeObserverRef.current) {
      iframeObserverRef.current.disconnect();
      iframeObserverRef.current = null;
    }
  };

  // ÂêØÂä®iframeÂÜÖÂÆπÂ§âÂåñÁõëÂê¨
  const startIframeContentMonitoring = () => {
    if (!iframeRef.current) {
      console.log('üö´ iframe‰∏çÂ≠òÂú®ÔºåÊó†Ê≥ïÂêØÂä®ÂÜÖÂÆπÁõëÂê¨');
      return;
    }
    
    console.log('üéØ ÂêØÂä®iframeÂÜÖÂÆπÁõëÂê¨');
    
    try {
      const iframe = iframeRef.current;
      
      // ÁõëÂê¨iframeÁöÑload‰∫ã‰ª∂
      iframe.onload = () => {
        console.log('üì• iframe Âä†ËΩΩÂÆåÊàê');
        setTimeout(async () => {
          if (isMultiPageMode && autoScreenshotEnabled) {
            const pageInfo = await detectPageInfo();
            if (pageInfo) {
              console.log('üì∑ iframeÂä†ËΩΩÂÆåÊàêÂêéÊà™Âõæ');
              handleAutoScreenshot(pageInfo);
            }
          }
        }, 1000);
        
        // Â∞ùËØïÊ∑ªÂä†iframeÂÜÖÈÉ®‰∫ã‰ª∂ÁõëÂê¨
        addIframeClickListener();
      };
      
      // Â∞ùËØïÁõëÂê¨iframeÂÜÖÈÉ®ÁöÑÁÇπÂáª‰∫ã‰ª∂
      const addIframeClickListener = () => {
        try {
          const iframeDoc = iframe.contentWindow.document;
          console.log('‚úÖ ÊàêÂäüËÆøÈóÆiframeÂÜÖÈÉ®ÊñáÊ°£ÔºåÊ∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨');
          
          // ÁõëÂê¨ÁÇπÂáª‰∫ã‰ª∂ - Êõ¥ÂπøÊ≥õÁöÑÂÖÉÁ¥†ÈÄâÊã©Âô®
          iframeDoc.addEventListener('click', (e) => {
            console.log('üñ±Ô∏è Ê£ÄÊµãÂà∞iframeÂÜÖÈÉ®ÁÇπÂáª:', {
              tagName: e.target.tagName,
              className: e.target.className,
              id: e.target.id,
              text: e.target.textContent?.substring(0, 50),
              href: e.target.href
            });
            
            // ÁâπÂà´Ê£ÄÊµãÂØºËà™ÈìæÊé•ÁÇπÂáª
            if (e.target.tagName === 'A' || e.target.closest('a')) {
              console.log('üîó ÁÇπÂáª‰∫ÜÈìæÊé•ÔºåÂº∫Âà∂Ê£ÄÊµãÈ°µÈù¢ÂèòÂåñ');
              // ÂØπÈìæÊé•ÁÇπÂáªÁªô‰∫àÊõ¥Â§öÊó∂Èó¥Á≠âÂæÖÈ°µÈù¢Âä†ËΩΩ
              setTimeout(async () => {
                await forceDetectPageChange();
              }, 800);
            } else {
              // ÊôÆÈÄöÁÇπÂáªÁöÑÂª∂ËøüÊ£ÄÊµã
              setTimeout(async () => {
                if (isMultiPageMode && autoScreenshotEnabled) {
                  const currentTime = Date.now();
                  // ÈÅøÂÖçËøá‰∫éÈ¢ëÁπÅÁöÑÊà™ÂõæÔºåÈó¥ÈöîËá≥Â∞ë3Áßí
                  if (currentTime - lastScreenshotTimeRef.current > 3000) {
                    console.log('‚è∞ ÁÇπÂáªÂêéÂª∂ËøüÊ£ÄÊµãÈ°µÈù¢ÂèòÂåñ');
                    const newPageInfo = await detectPageInfo();
                    if (newPageInfo) {
                      await handleAutoScreenshot(newPageInfo);
                      lastScreenshotTimeRef.current = currentTime;
                    }
                  }
                }
              }, 1000);
            }
          });
          
          // ÁõëÂê¨URLÂèòÂåñ - Êõ¥È¢ëÁπÅÁöÑÊ£ÄÊµã
          let lastUrl = iframe.contentWindow.location.href;
          console.log('üåê ÂºÄÂßãÁõëÂê¨URLÂèòÂåñÔºåÂàùÂßãURL:', lastUrl);
          
          const urlCheckInterval = setInterval(() => {
            try {
              const currentUrl = iframe.contentWindow.location.href;
              if (currentUrl !== lastUrl) {
                console.log('üîÑ URLÂèòÂåñÊ£ÄÊµã:', {
                  from: lastUrl,
                  to: currentUrl
                });
                lastUrl = currentUrl;
                
                if (isMultiPageMode && autoScreenshotEnabled) {
                  console.log('‚è±Ô∏è URLÂèòÂåñÔºå1ÁßíÂêéÊ£ÄÊµãÈ°µÈù¢');
                  setTimeout(async () => {
                    const newPageInfo = await detectPageInfo();
                    if (newPageInfo) {
                      console.log('üì∏ URLÂèòÂåñËß¶ÂèëÊà™Âõæ');
                      await handleAutoScreenshot(newPageInfo);
                    }
                  }, 1000); // Áº©Áü≠Á≠âÂæÖÊó∂Èó¥Âà∞1Áßí
                }
              }
            } catch (e) {
              // Ë∑®ÂüüÈôêÂà∂ÔºåÈùôÈªòÂ§ÑÁêÜ
              console.log('üö´ URLÊ£ÄÊµãÈÅáÂà∞Ë∑®ÂüüÈôêÂà∂');
            }
          }, 300); // ÊèêÈ´òÊ£ÄÊµãÈ¢ëÁéáÂà∞300ms
          
          // ‰øùÂ≠òintervalÂºïÁî®‰ª•‰æøÊ∏ÖÁêÜ
          if (iframeObserverRef.current) {
            clearInterval(iframeObserverRef.current);
          }
          iframeObserverRef.current = urlCheckInterval;
          
        } catch (error) {
          console.log('‚ö†Ô∏è Êó†Ê≥ïÁõëÂê¨iframeÂÜÖÈÉ®‰∫ã‰ª∂ÔºàË∑®ÂüüÈôêÂà∂Ôºâ:', error.message);
          // Âç≥‰ΩøË∑®Âüü‰πüÂ∞ùËØïÂ§ñÈÉ®ÁõëÂê¨ÊñπÊ°à
          setupExternalMonitoring();
        }
      };
      
      // Â§ñÈÉ®ÁõëÂê¨ÊñπÊ°àÔºàË∑®ÂüüÊó∂‰ΩøÁî®Ôºâ
      const setupExternalMonitoring = () => {
        console.log('üîß ËÆæÁΩÆÂ§ñÈÉ®ÁõëÂê¨ÊñπÊ°à');
        
        // ÁõëÂê¨iframeÁöÑload‰∫ã‰ª∂
        iframe.addEventListener('load', async () => {
          console.log('üì• Â§ñÈÉ®ÁõëÂê¨Âà∞iframeÂä†ËΩΩ‰∫ã‰ª∂');
          if (isMultiPageMode && autoScreenshotEnabled) {
            setTimeout(async () => {
              await forceDetectPageChange();
            }, 1000);
          }
        });
        
        // ‰ΩøÁî®MutationObserverÁõëÂê¨iframeÁöÑsrcÂèòÂåñ
        const observer = new MutationObserver((mutations) => {
          mutations.forEach(async (mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'src') {
              console.log('üîÑ Â§ñÈÉ®ÁõëÂê¨Âà∞iframe srcÂèòÂåñ');
              if (isMultiPageMode && autoScreenshotEnabled) {
                setTimeout(async () => {
                  await forceDetectPageChange();
                }, 1500);
              }
            }
          });
        });
        
        observer.observe(iframe, { attributes: true, attributeFilter: ['src'] });
        
        // ‰øùÂ≠òobserverÂºïÁî®‰ª•‰æøÊ∏ÖÁêÜ
        if (iframeObserverRef.current) {
          iframeObserverRef.current.disconnect();
        }
        iframeObserverRef.current = observer;
      };
      
      // Á≠âÂæÖiframeÂä†ËΩΩÂêéÂÜçÊ∑ªÂä†ÁõëÂê¨
      if (iframe.contentWindow && iframe.contentWindow.document.readyState === 'complete') {
        console.log('üìã iframeÂ∑≤Âä†ËΩΩÂÆåÊàêÔºåÁõ¥Êé•Ê∑ªÂä†ÁõëÂê¨');
        addIframeClickListener();
      } else {
        console.log('‚è≥ Á≠âÂæÖiframeÂä†ËΩΩÂÆåÊàê');
        iframe.addEventListener('load', addIframeClickListener);
      }
      
    } catch (error) {
      console.warn('‚ùå ÂêØÂä®iframeÂÜÖÂÆπÁõëÂê¨Â§±Ë¥•:', error);
    }
  };

  // Ëá™Âä®Êà™ÂõæÂäüËÉΩ
  const handleAutoScreenshot = async (pageInfo) => {
    if (!iframeRef.current || !pageInfo) return;

    try {
      console.log('Ê≠£Âú®‰∏∫È°µÈù¢Ëá™Âä®Êà™Âõæ:', pageInfo.title);
      
      // Êà™ÂèñiframeÂÜÖÂÆπ
      const iframe = iframeRef.current;
      const iframeDoc = iframe.contentWindow.document;
      
      const canvas = await html2canvas(iframeDoc.body, {
        useCORS: true,
        scale: 1,
        width: iframe.offsetWidth,
        height: iframe.offsetHeight,
        scrollX: 0,
        scrollY: 0,
        windowWidth: iframe.offsetWidth,
        windowHeight: iframe.offsetHeight
      });
      
      const screenshotDataUrl = canvas.toDataURL('image/png');
      
      // ‰øùÂ≠òÊà™ÂõæÂà∞ÁºìÂ≠ò
      setPageScreenshots(prev => ({
        ...prev,
        [pageInfo.pageKey]: {
          screenshot: screenshotDataUrl,
          pageInfo: pageInfo,
          timestamp: Date.now()
        }
      }));
      
      // Â∞ùËØïÂåπÈÖçËÆæËÆ°Âõæ
      await matchDesignImageForPage(pageInfo, screenshotDataUrl);
      
      console.log('È°µÈù¢Êà™ÂõæÂÆåÊàê:', pageInfo.title);
    } catch (error) {
      console.error('Ëá™Âä®Êà™ÂõæÂ§±Ë¥•:', error);
    }
  };

  // ÊâãÂä®Ëß¶ÂèëÊà™Âõæ
  const captureCurrentPage = async () => {
    const pageInfo = await detectPageInfo();
    if (pageInfo) {
      await handleAutoScreenshot(pageInfo);
    } else {
      alert('Unable to detect page information, possibly due to cross-origin restrictions');
    }
  };

  // Âº∫Âà∂Ê£ÄÊµãÈ°µÈù¢ÂèòÂåñ
  const forceDetectPageChange = async () => {
    console.log('Âº∫Âà∂Ê£ÄÊµãÈ°µÈù¢ÂèòÂåñ...');
    
    try {
      const newPageInfo = await detectPageInfo();
      if (newPageInfo) {
        console.log('Âº∫Âà∂Ê£ÄÊµãÁªìÊûú:', newPageInfo.title, newPageInfo.pageKey);
        
        // Êó†ËÆ∫ÊòØÂê¶ÂèòÂåñÈÉΩÊõ¥Êñ∞‰ø°ÊÅØÂπ∂Êà™Âõæ
        setCurrentPageInfo(newPageInfo);
        setPageChangeDetected(true);
        
        // Á´ãÂç≥Êà™Âõæ
        if (isMultiPageMode) {
          await handleAutoScreenshot(newPageInfo);
        }
        
        setTimeout(() => {
          setPageChangeDetected(false);
        }, 3000);
        
        console.log('Âº∫Âà∂Ê£ÄÊµãÂÆåÊàêÔºåÂ∑≤Êõ¥Êñ∞È°µÈù¢‰ø°ÊÅØ');
      } else {
        alert('Unable to detect page information, please check if the website loads normally');
      }
    } catch (error) {
      console.error('Âº∫Âà∂Ê£ÄÊµãÈîôËØØ:', error);
      alert('Detection failed, please try again later');
    }
  };

  // ËÆæËÆ°Âõæ‰∏éÈ°µÈù¢Êô∫ËÉΩÂåπÈÖçÁÆóÊ≥ï
  const matchDesignImageForPage = async (pageInfo, screenshot) => {
    if (!aiUploadedImages.length) return null;

    console.log('Ê≠£Âú®‰∏∫È°µÈù¢ÂåπÈÖçËÆæËÆ°Âõæ:', pageInfo.title);
    
    let bestMatch = null;
    let highestScore = 0;
    
    for (const designImage of aiUploadedImages) {
      const score = calculateMatchScore(pageInfo, designImage);
      
      if (score > highestScore) {
        highestScore = score;
        bestMatch = {
          designImage: designImage,
          score: score,
          matchReasons: generateMatchReasons(pageInfo, designImage, score)
        };
      }
    }
    
    // Âè™ÊúâÂΩìÂåπÈÖçÂàÜÊï∞Ë∂ÖËøáÈòàÂÄºÊó∂ÊâçËÆ§‰∏∫ÂåπÈÖçÊàêÂäü
    if (highestScore > 0.3) {
      setDesignImageMatching(prev => ({
        ...prev,
        [pageInfo.pageKey]: bestMatch
      }));
      
      console.log(`È°µÈù¢ "${pageInfo.title}" ÂåπÈÖçÂà∞ËÆæËÆ°Âõæ "${bestMatch.designImage.name}" (ÂàÜÊï∞: ${(highestScore * 100).toFixed(1)}%)`);
      return bestMatch;
    }
    
    console.log(`È°µÈù¢ "${pageInfo.title}" Êú™ÊâæÂà∞ÈÄÇÂêàÁöÑËÆæËÆ°ÂõæÂåπÈÖç`);
    return null;
  };

  // ËÆ°ÁÆóÂåπÈÖçÂàÜÊï∞
  const calculateMatchScore = (pageInfo, designImage) => {
    let score = 0;
    const fileName = designImage.name.toLowerCase();
    const pageTitle = pageInfo.title.toLowerCase();
    const pageType = pageInfo.pageType.toLowerCase();
    const pathname = pageInfo.pathname.toLowerCase();
    const mainHeading = pageInfo.mainHeading.toLowerCase();
    
    // 1. Êñá‰ª∂Âêç‰∏éÈ°µÈù¢Á±ªÂûãÂåπÈÖç (30%)
    if (fileName.includes(pageType)) {
      score += 0.3;
    }
    
    // 2. Êñá‰ª∂Âêç‰∏éË∑ØÂæÑÂåπÈÖç (25%)
    const pathSegments = pathname.split('/').filter(seg => seg.length > 0);
    for (const segment of pathSegments) {
      if (fileName.includes(segment)) {
        score += 0.25;
        break;
      }
    }
    
    // 3. Êñá‰ª∂Âêç‰∏éÈ°µÈù¢Ê†áÈ¢òÂåπÈÖç (20%)
    const titleWords = pageTitle.split(' ').filter(word => word.length > 2);
    for (const word of titleWords) {
      if (fileName.includes(word)) {
        score += 0.2;
        break;
      }
    }
    
    // 4. Êñá‰ª∂Âêç‰∏é‰∏ªÊ†áÈ¢òÂåπÈÖç (15%)
    if (mainHeading) {
      const headingWords = mainHeading.split(' ').filter(word => word.length > 2);
      for (const word of headingWords) {
        if (fileName.includes(word)) {
          score += 0.15;
          break;
        }
      }
    }
    
    // 5. ÁâπÊÆäÂÖ≥ÈîÆËØçÂåπÈÖç (10%)
    const specialKeywords = ['login', 'dashboard', 'home', 'profile', 'settings', 'about', 'contact'];
    for (const keyword of specialKeywords) {
      if (fileName.includes(keyword) && (pageType.includes(keyword) || pathname.includes(keyword) || pageTitle.includes(keyword))) {
        score += 0.1;
        break;
      }
    }
    
    return Math.min(1, score); // ÈôêÂà∂ÊúÄÂ§ßÂÄº‰∏∫1
  };

  // ÁîüÊàêÂåπÈÖçÂéüÂõ†ËØ¥Êòé
  const generateMatchReasons = (pageInfo, designImage, score) => {
    const reasons = [];
    const fileName = designImage.name.toLowerCase();
    const pageTitle = pageInfo.title.toLowerCase();
    const pageType = pageInfo.pageType.toLowerCase();
    const pathname = pageInfo.pathname.toLowerCase();
    
    if (fileName.includes(pageType)) {
      reasons.push(`Êñá‰ª∂ÂêçÂåÖÂê´È°µÈù¢Á±ªÂûã "${pageType}"`);
    }
    
    const pathSegments = pathname.split('/').filter(seg => seg.length > 0);
    for (const segment of pathSegments) {
      if (fileName.includes(segment)) {
        reasons.push(`Êñá‰ª∂ÂêçÂåπÈÖçË∑ØÂæÑ "${segment}"`);
        break;
      }
    }
    
    if (reasons.length === 0) {
      reasons.push('Âü∫‰∫éÊñá‰ª∂Âêç‰∏éÈ°µÈù¢‰ø°ÊÅØÁöÑÁõ∏‰ººÂ∫¶');
    }
    
    return reasons;
  };

  // Â∏∏ËßÅWebÁ´ØËÆæËÆ°Â∞∫ÂØ∏
  const designSizePresets = [
    { name: '1440√ó900 (Mainstream)', width: 1440, height: 900 },
    { name: '1920√ó1080 (Desktop)', width: 1920, height: 1080 },
    { name: '1366√ó768 (Laptop)', width: 1366, height: 768 },
    { name: '1280√ó720 (Small Screen)', width: 1280, height: 720 },
    { name: '1600√ó900 (Widescreen)', width: 1600, height: 900 }
  ];

  const isLocalhostUrl = (url) => {
    const lowerUrl = url.toLowerCase();
    return lowerUrl.includes('localhost') || 
           lowerUrl.includes('127.0.0.1') ||
           lowerUrl.match(/^https?:\/\/192\.168\./) ||
           lowerUrl.match(/^https?:\/\/10\./) ||
           lowerUrl.match(/^https?:\/\/172\.(1[6-9]|2[0-9]|3[0-1])\./);
  };

  const loadUrl = () => {
    if (url.trim()) {
      // Ê£ÄÊµãÊòØÂê¶‰∏∫Êú¨Âú∞Âú∞ÂùÄ
      if (isLocalhostUrl(url.trim())) {
        alert('‚ùå Web version does not support local addresses (localhost/internal IP)\n\nSuggestions:\n1. Deploy website to public address\n2. Use desktop version or browser extension\n3. Upload page screenshots for comparison');
        return;
      }
      
      console.log('=== Âä†ËΩΩURL ===', url.trim());
      setCurrentUrl(url.trim());
      // ÈáçÁΩÆÈ°µÈù¢ÁõëÂê¨Áä∂ÊÄÅ
      setCurrentPageInfo(null);
      setPageScreenshots({});
      setDesignImageMatching({});
      lastScreenshotTimeRef.current = 0;
      
      // Âè™ÊúâÂú®Â§öÈ°µÈù¢Ê®°Âºè‰∏ãÊâçÂêØÂä®ÁõëÂê¨
      setTimeout(() => {
        if (isMultiPageMode) {
          console.log('Â§öÈ°µÈù¢Ê®°ÂºèÂ∑≤ÂêØÁî®ÔºåÂºÄÂßãÁõëÂê¨È°µÈù¢ÂèòÂåñ');
          startPageMonitoring();
          startIframeContentMonitoring();
        } else {
          console.log('ÂçïÈ°µÈù¢Ê®°ÂºèÔºå‰∏çÂêØÂä®È°µÈù¢ÁõëÂê¨');
        }
      }, 1000);
    }
  };

  // ÁªÑ‰ª∂Âç∏ËΩΩÊó∂Ê∏ÖÁêÜÁõëÂê¨
  React.useEffect(() => {
    return () => {
      stopPageMonitoring();
    };
  }, []);

  // ÂàáÊç¢Âà∞Â§öÈ°µÈù¢Ê®°Âºè
  const enableMultiPageMode = () => {
    console.log('=== ÂêØÁî®Â§öÈ°µÈù¢Ê®°Âºè ===');
    setIsMultiPageMode(true);
    setAutoScreenshotEnabled(true);
    if (currentUrl) {
      console.log('Â∑≤ÊúâURLÔºåÂºÄÂßãÈ°µÈù¢ÁõëÂê¨:', currentUrl);
      startPageMonitoring();
      startIframeContentMonitoring();
    } else {
      console.log('ÊöÇÊó†URLÔºåÁ≠âÂæÖÂä†ËΩΩÈ°µÈù¢ÂêéÂÜçÂêØÂä®ÁõëÂê¨');
    }
  };

  // ÂÖ≥Èó≠Â§öÈ°µÈù¢Ê®°Âºè
  const disableMultiPageMode = () => {
    setIsMultiPageMode(false);
    setAutoScreenshotEnabled(false);
    stopPageMonitoring();
  };

  // Â§ÑÁêÜÂçï‰∏™È°µÈù¢ÁöÑAIËµ∞Êü•
  const handleAutoInspectPage = async (pageKey, pageData, matchInfo) => {
    if (!matchInfo) {
      alert('This page has no matching design image, cannot perform AI inspection');
      return;
    }

    try {
      setIsAIProcessing(true);
      setAiProgress({ step: `Ê≠£Âú®ÂØπÈ°µÈù¢ "${pageData.pageInfo.title}" ËøõË°åAIËµ∞Êü•...`, progress: 10 });
      
      // Ê®°ÊãüAIËµ∞Êü•ÊµÅÁ®ã
      const aiIssues = await simulateAIInspectionForPage(pageData, matchInfo);
      
      // Â∞ÜÈóÆÈ¢òÊ∑ªÂä†Âà∞ÈóÆÈ¢òÂàóË°®
      setIssues(prev => [
        ...prev,
        ...aiIssues.map(issue => ({
          ...issue,
          pageInfo: pageData.pageInfo,
          matchedDesign: matchInfo.designImage.name
        }))
      ]);
      
      setAiProgress({ step: `È°µÈù¢ "${pageData.pageInfo.title}" AIËµ∞Êü•ÂÆåÊàêÔºåÂèëÁé∞${aiIssues.length}‰∏™ÈóÆÈ¢ò`, progress: 100 });
      
      setTimeout(() => {
        setIsAIProcessing(false);
        setAiProgress({ step: '', progress: 0 });
      }, 2000);
      
    } catch (error) {
      console.error('AIËµ∞Êü•ÈîôËØØ:', error);
      setIsAIProcessing(false);
      setAiProgress({ step: '', progress: 0 });
      alert('AIËµ∞Êü•Â§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï');
    }
  };

  // Ê®°ÊãüAIËµ∞Êü•Âçï‰∏™È°µÈù¢
  const simulateAIInspectionForPage = async (pageData, matchInfo) => {
    // Ê®°ÊãüÂª∂Ëøü
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Ê†πÊçÆÈ°µÈù¢Á±ªÂûãÁîüÊàê‰∏çÂêåÁöÑÈóÆÈ¢ò
    const pageType = pageData.pageInfo.pageType;
    const mockIssues = [];
    
    // Ê†πÊçÆÈ°µÈù¢Á±ªÂûãÁîüÊàêÂØπÂ∫îÁöÑÈóÆÈ¢ò
    switch (pageType) {
      case 'login':
        mockIssues.push({
          id: Date.now() + Math.random(),
          screenshot: pageData.screenshot,
          description: `ÁôªÂΩïË°®ÂçïËæìÂÖ•Ê°ÜÈó¥Ë∑ù‰∏éËÆæËÆ°Á®ø‰∏ç‰∏ÄËá¥ÔºåÂÆûÈôÖÈó¥Ë∑ù‰∏∫12pxÔºåËÆæËÆ°Ë¶ÅÊ±Ç16px`,
          suggestion: 'Ë∞ÉÊï¥ËæìÂÖ•Ê°ÜÁöÑmargin-bottom‰∏∫16px',
          status: 'Not Verified',
          source: 'AI Inspection'
        });
        break;
      case 'dashboard':
        mockIssues.push({
          id: Date.now() + Math.random(),
          screenshot: pageData.screenshot,
          description: `‰ª™Ë°®ÊùøÂç°ÁâáÈò¥ÂΩ±ÊïàÊûú‰∏éËÆæËÆ°Á®øÂ∑ÆÂºÇËæÉÂ§ßÔºåÂÆûÈôÖ‰∏∫box-shadow: 0 2px 4pxÔºåËÆæËÆ°Ë¶ÅÊ±Ç: 0 4px 8px`,
          suggestion: '‰øÆÊîπÂç°ÁâáÁöÑbox-shadow‰∏∫0 4px 8px rgba(0,0,0,0.1)',
          status: 'Not Verified',
          source: 'AI Inspection'
        });
        break;
      default:
        mockIssues.push({
          id: Date.now() + Math.random(),
          screenshot: pageData.screenshot,
          description: `È°µÈù¢ÂÜÖÂÆπ‰∏éËÆæËÆ°Á®øÂ≠òÂú®ÂæÆÂ∞èÂ∑ÆÂºÇÔºåÂèØËÉΩÊ∂âÂèäÂ≠ó‰Ωì„ÄÅÈó¥Ë∑ùÊàñÈ¢úËâ≤Á≠âÊñπÈù¢`,
          suggestion: 'ËØ∑ÂØπÁÖßËÆæËÆ°Á®ø‰ªîÁªÜÊ£ÄÊü•È°µÈù¢ÁªÜËäÇÂπ∂Ë∞ÉÊï¥',
          status: 'Not Verified',
          source: 'AI Inspection'
        });
        break;
    }
    
    return mockIssues;
  };

  // ÊâπÈáèAIËµ∞Êü•ÊâÄÊúâÈ°µÈù¢
  const handleBatchAIInspection = async () => {
    const pagesWithMatches = Object.entries(pageScreenshots)
      .filter(([pageKey]) => designImageMatching[pageKey])
      .map(([pageKey, pageData]) => ({
        pageKey,
        pageData,
        matchInfo: designImageMatching[pageKey]
      }));

    if (pagesWithMatches.length === 0) {
      alert('No pages have matching design images, cannot perform batch AI inspection');
      return;
    }

    if (!window.confirm(`Are you sure you want to perform batch AI inspection on ${pagesWithMatches.length} pages?`)) {
      return;
    }

    try {
      setIsAIProcessing(true);
      let totalIssues = [];

      for (let i = 0; i < pagesWithMatches.length; i++) {
        const { pageKey, pageData, matchInfo } = pagesWithMatches[i];
        
        setAiProgress({
          step: `Ê≠£Âú®Ê£ÄÊü•È°µÈù¢ ${i + 1}/${pagesWithMatches.length}: "${pageData.pageInfo.title}"`,
          progress: ((i + 1) / pagesWithMatches.length) * 90
        });

        const pageIssues = await simulateAIInspectionForPage(pageData, matchInfo);
        totalIssues = [
          ...totalIssues,
          ...pageIssues.map(issue => ({
            ...issue,
            pageInfo: pageData.pageInfo,
            matchedDesign: matchInfo.designImage.name
          }))
        ];

        // ÈÅøÂÖçËøá‰∫éÈ¢ëÁπÅÁöÑËØ∑Ê±Ç
        if (i < pagesWithMatches.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }

      // Â∞ÜÊâÄÊúâÈóÆÈ¢òÊ∑ªÂä†Âà∞ÈóÆÈ¢òÂàóË°®
      setIssues(prev => [...prev, ...totalIssues]);
      
      setAiProgress({
        step: `ÊâπÈáèAIËµ∞Êü•ÂÆåÊàêÔºÅÂÖ±Ê£ÄÊü•${pagesWithMatches.length}‰∏™È°µÈù¢ÔºåÂèëÁé∞${totalIssues.length}‰∏™ÈóÆÈ¢ò`,
        progress: 100
      });

      setTimeout(() => {
        setIsAIProcessing(false);
        setAiProgress({ step: '', progress: 0 });
      }, 3000);

    } catch (error) {
      console.error('ÊâπÈáèAIËµ∞Êü•ÈîôËØØ:', error);
      setIsAIProcessing(false);
      setAiProgress({ step: '', progress: 0 });
      alert('ÊâπÈáèAIËµ∞Êü•Â§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï');
    }
  };

  const clearPage = () => {
    setUrl('');
    setCurrentUrl('');
    setDesignImage(null);
    setImagePosition({ x: 0, y: 0 });
    setImageSize({ width: 400, height: 300 });
    setImageScale(1);
    setImageTransformOrigin('center center');
    setSelection(null);
    setSelectionStart(null);
    setIsSelecting(false);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };



  // ÂàáÊç¢ËÆæËÆ°Â∞∫ÂØ∏
  const handleDesignSizeChange = (event) => {
    const selectedIndex = event.target.value;
    const selectedPreset = designSizePresets[selectedIndex];
    setDesignSize({ width: selectedPreset.width, height: selectedPreset.height });
  };

  const handleImageUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      // Ê£ÄÊü•Êñá‰ª∂Â§ßÂ∞è (10MB = 10 * 1024 * 1024 bytes)
      const maxSize = 10 * 1024 * 1024;
      if (file.size > maxSize) {
        alert(`ÂõæÁâáÊñá‰ª∂ËøáÂ§ß (${(file.size / 1024 / 1024).toFixed(1)}MB)ÔºåËØ∑ÈÄâÊã©Â∞è‰∫é10MBÁöÑÂõæÁâá`);
        event.target.value = ''; // Ê∏ÖÈô§Êñá‰ª∂ÈÄâÊã©
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          setDesignImage(e.target.result);
          
          // ËÆæÁΩÆÂàùÂßãÂ∞∫ÂØ∏
          const maxWidth = 500;
          const maxHeight = 400;
          let width = img.width;
          let height = img.height;
          
          // Â¶ÇÊûúÂõæÁâáÂ§™Â§ßÔºåÊåâÊØî‰æãÁº©Â∞è
          if (width > maxWidth || height > maxHeight) {
            const scaleX = maxWidth / width;
            const scaleY = maxHeight / height;
            const scale = Math.min(scaleX, scaleY);
            width = Math.round(width * scale);
            height = Math.round(height * scale);
          }
          
          setImageSize({ width, height });
          setImagePosition({ x: 100, y: 100 });
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
  };

  const triggerImageUpload = () => {
    fileInputRef.current.click();
  };

  const removeDesignImage = () => {
    setDesignImage(null);
    setImagePosition({ x: 0, y: 0 });
    setImageSize({ width: 400, height: 300 });
    setImageScale(1);
    setImageTransformOrigin('center center');
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleImageMouseDown = (e) => {
    // Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáªÂú®resize handle‰∏ä
    if (e.target.classList.contains('resize-handle') || 
        e.target.closest('.resize-handle')) {
      return; // ÈÅøÂÖçÂíåÁº©ÊîæÂÜ≤Á™Å
    }
    
    // Á°Æ‰øùÁÇπÂáªÁöÑÊòØÂõæÁâáÊú¨Ë∫´ÊàñÂõæÁâáÂÆπÂô®
    if (!e.target.classList.contains('design-image') && 
        !e.target.classList.contains('design-overlay')) {
      return;
    }
    
    e.preventDefault();
    e.stopPropagation();
    
    // Ê∑ªÂä†Êõ¥‰∏•Ê†ºÁöÑÁä∂ÊÄÅÊ£ÄÊü•
    if (isResizing || isSelecting) {
      return;
    }
    
    setIsDragging(true);
    setDragStart({
      x: e.clientX - imagePosition.x,
      y: e.clientY - imagePosition.y
    });
  };

  const handleResizeMouseDown = (e, direction) => {
    e.preventDefault();
    e.stopPropagation();
    
    // Âè™ÈòªÊ≠¢ÈÄâÊã©Ê®°ÂºèÔºåÂÖÅËÆ∏Âú®ÊãñÊãΩÊó∂ÂàáÊç¢Âà∞Áº©Êîæ
    if (isSelecting) {
      return;
    }
    
    // Ê∏ÖÁêÜÂÖ∂‰ªñÁä∂ÊÄÅ
    setIsDragging(false);
    setDragStart(null);
    setIsResizing(true);
    
    // ËÆæÁΩÆtransform-originÊ†πÊçÆÊñπÂêë
    let origin = 'center center';
    switch (direction) {
      case 'nw': origin = 'bottom right'; break;
      case 'ne': origin = 'bottom left'; break;
      case 'sw': origin = 'top right'; break;
      case 'se': origin = 'top left'; break;
      case 'n': origin = 'bottom center'; break;
      case 's': origin = 'top center'; break;
      case 'w': origin = 'right center'; break;
      case 'e': origin = 'left center'; break;
    }
    setImageTransformOrigin(origin);
    
    setResizeStart({
      x: e.clientX,
      y: e.clientY,
      direction: direction,
      startScale: imageScale
    });
  };

  const handleMouseMove = useCallback((e) => {
    // Áõ¥Êé•Â§ÑÁêÜÊãñÊãΩ
    if (isDragging && dragStart) {
      const newX = e.clientX - dragStart.x;
      const newY = e.clientY - dragStart.y;
      setImagePosition({ x: newX, y: newY });
      return;
    }

    // Áõ¥Êé•Â§ÑÁêÜÈÄâÊã©
    if (isSelecting && selectionStart) {
      const rect = previewRef.current?.getBoundingClientRect();
      if (rect) {
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        setSelection({
          left: Math.min(selectionStart.x, currentX),
          top: Math.min(selectionStart.y, currentY),
          width: Math.abs(currentX - selectionStart.x),
          height: Math.abs(currentY - selectionStart.y)
        });
      }
      return;
    }


    // ‰ΩøÁî®transformÁº©ÊîæÂ§ÑÁêÜ
    if (isResizing && resizeStart) {
      const deltaX = e.clientX - resizeStart.x;
      const deltaY = e.clientY - resizeStart.y;
      
      // Ê†πÊçÆÊãñÊãΩÊñπÂêëËÆ°ÁÆóÁº©ÊîæÂ¢ûÈáè - ÊèêÈ´òÁÅµÊïèÂ∫¶
      let scaleChange = 0;
      const sensitivity = 100; // Èôç‰ΩéÊï∞ÂÄºÊèêÈ´òÁÅµÊïèÂ∫¶
      
      switch (resizeStart.direction) {
        case 'se': // Âè≥‰∏ãËßí - ÂêëÂè≥‰∏ãÊãñÊãΩÊîæÂ§ß
          scaleChange = Math.max(deltaX, deltaY) / sensitivity;
          break;
        case 'nw': // Â∑¶‰∏äËßí - ÂêëÂ∑¶‰∏äÊãñÊãΩÊîæÂ§ß
          scaleChange = Math.max(-deltaX, -deltaY) / sensitivity;
          break;
        case 'ne': // Âè≥‰∏äËßí - ÂêëÂè≥‰∏äÊãñÊãΩÊîæÂ§ß
          scaleChange = Math.max(deltaX, -deltaY) / sensitivity;
          break;
        case 'sw': // Â∑¶‰∏ãËßí - ÂêëÂ∑¶‰∏ãÊãñÊãΩÊîæÂ§ß
          scaleChange = Math.max(-deltaX, deltaY) / sensitivity;
          break;
        case 'e': // Âè≥Ëæπ - ÂêëÂè≥ÊãñÊãΩÊîæÂ§ß
          scaleChange = deltaX / sensitivity;
          break;
        case 'w': // Â∑¶Ëæπ - ÂêëÂ∑¶ÊãñÊãΩÊîæÂ§ß
          scaleChange = -deltaX / sensitivity;
          break;
        case 's': // ‰∏ãËæπ - Âêë‰∏ãÊãñÊãΩÊîæÂ§ß
          scaleChange = deltaY / sensitivity;
          break;
        case 'n': // ‰∏äËæπ - Âêë‰∏äÊãñÊãΩÊîæÂ§ß
          scaleChange = -deltaY / sensitivity;
          break;
      }
      
      // ËÆ°ÁÆóÊñ∞ÁöÑÁº©ÊîæÂÄºÔºåÂ¢ûÂä†Êõ¥Â§ßÁöÑËåÉÂõ¥
      const newScale = Math.max(0.1, Math.min(10, resizeStart.startScale + scaleChange));
      setImageScale(newScale);
    }
  }, [isDragging, dragStart, isResizing, resizeStart, isSelecting, selectionStart]);

  const handleMouseUp = useCallback(async () => {
    // ‰øùÂ≠òÂΩìÂâçÁä∂ÊÄÅ
    const wasDragging = isDragging;
    const wasResizing = isResizing;
    const wasSelecting = isSelecting;
    
    // Á´ãÂç≥Ê∏ÖÁêÜÊâÄÊúâÁä∂ÊÄÅÔºåÈò≤Ê≠¢Áä∂ÊÄÅÊÆãÁïô
    setIsDragging(false);
    setIsResizing(false);
    setDragStart(null);
    setResizeStart(null);
    
    if (wasResizing) {
      // Áº©ÊîæÁªìÊùüÂêéÈáçÁΩÆtransform-origin
      setTimeout(() => setImageTransformOrigin('center center'), 50);
    }
    
    // Ê°ÜÈÄâÂÆåÊàêÂêé‰∏çÂÅö‰ªª‰ΩïÂ§ÑÁêÜÔºåÁ≠âÂæÖÁî®Êà∑ÁÇπÂáªÊåâÈíÆ
    if (wasSelecting && selection && selection.width > 10 && selection.height > 10) {
      setIsSelecting(false);
    }
    
  }, [isSelecting, selection]);

  React.useEffect(() => {
    if (isDragging || isResizing || isSelecting) {
      const handleGlobalMouseMove = (e) => {
        handleMouseMove(e);
      };
      
      const handleGlobalMouseUp = (e) => {
        handleMouseUp(e);
      };
      
      // Ê∑ªÂä†ÂÖ®Â±Ä‰∫ã‰ª∂ÁõëÂê¨ÔºåÂåÖÊã¨window‰∫ã‰ª∂
      document.addEventListener('mousemove', handleGlobalMouseMove);
      document.addEventListener('mouseup', handleGlobalMouseUp);
      window.addEventListener('blur', handleGlobalMouseUp); // Á™óÂè£Â§±ÁÑ¶Êó∂Ê∏ÖÁêÜ
      document.addEventListener('mouseleave', handleGlobalMouseUp); // Èº†Ê†áÁ¶ªÂºÄÊñáÊ°£Êó∂Ê∏ÖÁêÜ
      
      return () => {
        document.removeEventListener('mousemove', handleGlobalMouseMove);
        document.removeEventListener('mouseup', handleGlobalMouseUp);
        window.removeEventListener('blur', handleGlobalMouseUp);
        document.removeEventListener('mouseleave', handleGlobalMouseUp);
      };
    }
  }, [isDragging, isResizing, isSelecting, handleMouseMove, handleMouseUp]);

  // ÁõëÂê¨Ê°ÜÈÄâÂÆåÊàêÔºåÊòæÁ§∫Êà™ÂõæÊèêÁ§∫
  React.useEffect(() => {
    if (!isSelecting && selection && selection.width > 10 && selection.height > 10) {
      // Ê°ÜÈÄâÂÆåÊàêÂêéÔºåÊòæÁ§∫Êà™ÂõæÊèêÁ§∫
      setShowScreenshotTip(true);
      // È´ò‰∫ÆÊòæÁ§∫È¢ÑËßàÂå∫ÂüüÔºàÁ∫¢Ê°Ü‰∏ÄÁõ¥ÊòæÁ§∫Ôºâ
      if (previewRef.current) {
        previewRef.current.style.boxShadow = '0 0 0 4px #ff0000';
        previewRef.current.style.transition = 'box-shadow 0.3s ease';
      }
      // ‰∏çËá™Âä®ÈöêËóèÊèêÁ§∫ÔºåËÆ©Áî®Êà∑‰∏ªÂä®Êìç‰Ωú
    }
  }, [isSelecting, selection]);


  const startSelection = () => {
    setIsSelecting(true);
    setSelection(null);
  };

  const cancelSelection = () => {
    setIsSelecting(false);
    setSelection(null);
    setSelectionStart(null);
    // Ê∏ÖÈô§Ê°ÜÈÄâÊó∂ÊâçÁßªÈô§Á∫¢Ê°ÜÈ´ò‰∫ÆÂíåÊèêÁ§∫
    setShowScreenshotTip(false);
    if (previewRef.current) {
      previewRef.current.style.boxShadow = '';
    }
  };

  // ÂÖ≥Èó≠Êà™ÂõæÊèêÁ§∫Ôºà‰ΩÜ‰øùÊåÅÁ∫¢Ê°ÜÊòæÁ§∫Ôºâ
  const closeScreenshotTip = () => {
    setShowScreenshotTip(false);
    // ‰∏çÁßªÈô§Á∫¢Ê°ÜÈ´ò‰∫ÆÔºåËÆ©Á∫¢Ê°ÜÁªßÁª≠ÊòæÁ§∫Áõ¥Âà∞Áî®Êà∑Ê∏ÖÈô§Ê°ÜÈÄâ
  };

  // Ê£ÄÊü•ÊòØÂê¶ÊîØÊåÅÂâ™Ë¥¥ÊùøAPI
  const isClipboardSupported = () => {
    return navigator.clipboard && 
           window.isSecureContext && 
           typeof navigator.clipboard.read === 'function';
  };

  // Â§ÑÁêÜÂâ™Ë¥¥ÊùøÊà™ÂõæÁ≤òË¥¥
  const handlePasteScreenshot = async () => {
    try {
      // Ê£ÄÊü•Ââ™Ë¥¥ÊùøAPIÊîØÊåÅ
      if (!isClipboardSupported()) {
        alert('‚ùå ÂΩìÂâçÁéØÂ¢É‰∏çÊîØÊåÅÂâ™Ë¥¥ÊùøËÆøÈóÆ\n\nÂéüÂõ†ÔºöÈúÄË¶ÅHTTPSÁéØÂ¢ÉÊâçËÉΩËÆøÈóÆÂâ™Ë¥¥Êùø\n\nÂª∫ËÆÆÔºö\n1. ‰ΩøÁî®HTTPSËÆøÈóÆÊú¨Â∫îÁî®\n2. ÊàñËÄÖ‰ΩøÁî®Êñá‰ª∂‰∏ä‰º†ÊñπÂºèÊ∑ªÂä†Êà™Âõæ');
        return;
      }

      const clipboardItems = await navigator.clipboard.read();
      
      for (const item of clipboardItems) {
        if (item.types.includes('image/png')) {
          const blob = await item.getType('image/png');
          const reader = new FileReader();
          
          reader.onload = (e) => {
            setModalScreenshot(e.target.result);
            // ÂÖ≥Èó≠ÊèêÁ§∫‰ΩÜ‰øùÊåÅÁ∫¢Ê°ÜÔºàÁ∫¢Ê°Ü‰ºöÂú®Áî®Êà∑Ê∏ÖÈô§Ê°ÜÈÄâÊàñ‰øùÂ≠òÈóÆÈ¢òÂêéÊ∏ÖÈô§Ôºâ
            setShowScreenshotTip(false);
            setShowModal(true);
          };
          
          reader.readAsDataURL(blob);
          return;
        }
      }
      
      // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÂõæÁâáÔºåÊèêÁ§∫Áî®Êà∑
      alert('Ââ™Ë¥¥Êùø‰∏≠Ê≤°ÊúâÊâæÂà∞ÂõæÁâáÔºåËØ∑ÂÖàÁî® Win+Shift+S Êà™Âõæ');
      
    } catch (error) {
      console.error('ËØªÂèñÂâ™Ë¥¥ÊùøÂ§±Ë¥•:', error);
      alert('Êó†Ê≥ïËÆøÈóÆÂâ™Ë¥¥ÊùøÔºåËØ∑ÂÖàÁî® Win+Shift+S Êà™ÂõæÂÜçÈáçËØï');
    }
  };

  // ÂºÄÂßãÊà™ÂõæÊ®°Âºè
  const startScreenshot = () => {
    setIsSelecting(true);
    setSelection(null);
    setSelectionStart(null);
  };

  // AIËµ∞Êü•Áõ∏ÂÖ≥ÂáΩÊï∞ - ÁÆÄÂåñ‰∏∫ÂçïÊñá‰ª∂‰∏ä‰º†
  const handleAIImageUpload = (files) => {
    console.log('handleAIImageUpload Ë¢´Ë∞ÉÁî®ÔºåÊñá‰ª∂Êï∞Èáè:', files.length);
    
    if (!files || files.length === 0) {
      console.log('Ê≤°ÊúâÈÄâÊã©Êñá‰ª∂');
      return;
    }

    // Âè™Â§ÑÁêÜÁ¨¨‰∏Ä‰∏™Êñá‰ª∂
    const file = files[0];
    console.log('Â§ÑÁêÜËÆæËÆ°ÂõæÊñá‰ª∂:', file.name, file.type, file.size);
    
    // Ê£ÄÊü•Êñá‰ª∂Á±ªÂûã
    if (!['image/png', 'image/jpg', 'image/jpeg'].includes(file.type)) {
      alert(`Êñá‰ª∂Ê†ºÂºè‰∏çÊîØÊåÅÔºåËØ∑ÈÄâÊã©PNG„ÄÅJPGÊàñJPEGÊ†ºÂºè`);
      return;
    }
    
    // Ê£ÄÊü•Êñá‰ª∂Â§ßÂ∞è
    if (file.size > 10 * 1024 * 1024) {
      alert(`Êñá‰ª∂ËøáÂ§ßÔºà${(file.size/1024/1024).toFixed(1)}MBÔºâÔºåËØ∑ÈÄâÊã©Â∞è‰∫é10MBÁöÑÊñá‰ª∂`);
      return;
    }

    // ËØªÂèñÊñá‰ª∂
    const reader = new FileReader();
    reader.onload = (e) => {
      console.log(`ËÆæËÆ°Âõæ ${file.name} ËØªÂèñÊàêÂäü`);
      
      const imageData = {
        name: file.name,
        data: e.target.result,
        size: file.size
      };

      // ÊõøÊç¢ËÄå‰∏çÊòØËøΩÂä†
      setAiUploadedImages([imageData]);
      console.log('ËÆæÁΩÆAIËÆæËÆ°Âõæ:', imageData.name);
    };
    
    reader.onerror = (error) => {
      console.error(`ËØªÂèñËÆæËÆ°ÂõæÂ§±Ë¥•:`, error);
      alert(`ËØªÂèñËÆæËÆ°ÂõæÂ§±Ë¥•`);
    };
    
    reader.readAsDataURL(file);
  };

  const removeAIImage = (index) => {
    setAiUploadedImages(prev => prev.filter((_, i) => i !== index));
  };

  // ÊâπÈáèÈÄâÊã©Áõ∏ÂÖ≥ÂáΩÊï∞
  const toggleMultiSelectMode = () => {
    setIsMultiSelectMode(!isMultiSelectMode);
    if (isMultiSelectMode) {
      setSelectedIssues(new Set());
    }
  };

  const toggleIssueSelection = (issueId) => {
    setSelectedIssues(prev => {
      const newSet = new Set(prev);
      if (newSet.has(issueId)) {
        newSet.delete(issueId);
      } else {
        newSet.add(issueId);
      }
      return newSet;
    });
  };

  const selectAllIssues = () => {
    const allIds = new Set(issues.map(issue => issue.id));
    setSelectedIssues(allIds);
  };

  const deselectAllIssues = () => {
    setSelectedIssues(new Set());
  };

  const batchDeleteIssues = () => {
    if (selectedIssues.size === 0) {
      alert('Please select issues to delete first');
      return;
    }
    
    if (window.confirm(`Are you sure you want to delete the selected ${selectedIssues.size} issues?`)) {
      setIssues(prev => prev.filter(issue => !selectedIssues.has(issue.id)));
      setSelectedIssues(new Set());
      setIsMultiSelectMode(false);
    }
  };

  const startAIInspection = async () => {
    if (aiUploadedImages.length === 0) {
      alert('ËØ∑ÂÖà‰∏ä‰º†ËÆæËÆ°Âõæ');
      return;
    }

    if (!currentUrl) {
      alert('ËØ∑ÂÖàÂä†ËΩΩÁΩëÈ°µ');
      return;
    }

    setIsAIProcessing(true);
    setAiProgress({ step: 'ÂáÜÂ§áAIËµ∞Êü•...', progress: 10 });

    try {
      // Ê®°ÊãüAIËµ∞Êü•ÊµÅÁ®ã
      await simulateAIInspection();
    } catch (error) {
      console.error('AIËµ∞Êü•Â§±Ë¥•:', error);
      alert('AIËµ∞Êü•Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
    } finally {
      setIsAIProcessing(false);
      setShowAIModal(false);
      setAiProgress({ step: '', progress: 0 });
    }
  };

  const simulateAIInspection = async () => {
    try {
      // Ê≠•È™§1ÔºöËé∑ÂèñiframeÂÜÖÂÆπÂπ∂Êà™Âõæ
      setAiProgress({ step: '', progress: 10 });
      const webpageCanvas = await captureIframeContent();
      
      // Ê≠•È™§2ÔºöËß£ÊûêËÆæËÆ°ÂõæÁªìÊûÑ
      setAiProgress({ step: '', progress: 20 });
      const aiInspector = new window.AIInspector();
      
      // Ê≠•È™§3ÔºöÂÉèÁ¥†Â∑ÆÂºÇÊ£ÄÊµã
      setAiProgress({ step: '', progress: 35 });
      
      if (aiUploadedImages.length === 0) {
        throw new Error('ËØ∑ÂÖà‰∏ä‰º†ËÆæËÆ°Âõæ');
      }
      
      // Ê≠•È™§4ÔºöUIÂÖÉÁ¥†ÂàÜÁ±ª
      setAiProgress({ step: '', progress: 50 });
      
      // ÊâßË°åAIËµ∞Êü•
      const inspectionResult = await aiInspector.executeAIInspection(
        aiUploadedImages[0].data, 
        webpageCanvas
      );
      
      // Ê≠•È™§5ÔºöÁªìÊûÑÂåñÂØπÊØî
      setAiProgress({ step: '', progress: 70 });
      
      if (!inspectionResult.success) {
        throw new Error(inspectionResult.error || 'AIËµ∞Êü•Â§±Ë¥•');
      }
      
      // Ê≠•È™§6ÔºöÁ≤æÁ°ÆÈóÆÈ¢òÊèèËø∞ÁîüÊàê
      setAiProgress({ step: '', progress: 85 });
      
      // Ê≠•È™§7ÔºöÊ†ºÂºèÂåñÈóÆÈ¢òÂπ∂Ê∑ªÂä†Âà∞ÂàóË°®
      setAiProgress({ step: '', progress: 95 });
      
      const aiGeneratedIssues = inspectionResult.regions.map((region, index) => ({
        id: `ai-${Date.now()}-${index + 1}`,
        screenshot: region.screenshot,
        description: region.description,
        suggestion: region.suggestion,
        status: 'Not Verified',
        source: 'AI Inspection',
        elementType: region.elementType,
        confidence: region.confidence,
        severity: region.severity
      }));
      
      // Ê∑ªÂä†Âà∞ÈóÆÈ¢òÂàóË°®
      setIssues(prev => [...prev, ...aiGeneratedIssues]);
      
      const message = inspectionResult.regions.length > 0 
        ? `AIËµ∞Êü•ÂÆåÊàêÔºÅÂèëÁé∞ ${aiGeneratedIssues.length} ‰∏™Â∑ÆÂºÇÈóÆÈ¢ò` 
        : 'È°µÈù¢‰∏éËÆæËÆ°Á®øÈ´òÂ∫¶‰∏ÄËá¥ÔºåÊú™ÂèëÁé∞ÊòæËëóÂ∑ÆÂºÇ';
        
      setAiProgress({ step: message, progress: 100 });
      await new Promise(resolve => setTimeout(resolve, 1500));
      
    } catch (error) {
      console.error('AIËµ∞Êü•Â§±Ë¥•:', error);
      setAiProgress({ step: `Ëµ∞Êü•Â§±Ë¥•Ôºö${error.message}`, progress: 0 });
      await new Promise(resolve => setTimeout(resolve, 2000));
      throw error;
    }
  };

  // 1. ÊçïËé∑iframeÂÜÖÂÆπÁöÑÁúüÂÆûÊà™Âõæ
  const captureIframeContent = async () => {
    try {
      console.log('ÂºÄÂßãÊçïËé∑iframeÂÜÖÂÆπ...');
      
      // ÊñπÊ≥ï1ÔºöÂ∞ùËØïÁõ¥Êé•Êà™Âõæiframe
      if (iframeRef.current) {
        console.log('ÊâæÂà∞iframeÂÖÉÁ¥†ÔºåÂ∞∫ÂØ∏:', iframeRef.current.offsetWidth, 'x', iframeRef.current.offsetHeight);
        
        // Á≠âÂæÖiframeÂÆåÂÖ®Âä†ËΩΩ
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Ê£ÄÊü•ÊòØÂê¶ËÉΩËÆøÈóÆiframeÂÜÖÂÆπÔºàÂêåÂüüÂêçÔºâ
        try {
          const iframeDoc = iframeRef.current.contentDocument || iframeRef.current.contentWindow.document;
          if (iframeDoc) {
            console.log('‚úÖ ÊàêÂäüËÆøÈóÆiframeÂÜÖÂÆπÔºåÁõ¥Êé•Êà™Âõæ');
            // ËÉΩËÆøÈóÆiframeÂÜÖÂÆπÔºåÁõ¥Êé•Êà™Âõæ
            const canvas = await html2canvas(iframeDoc.body, {
              useCORS: true,
              allowTaint: true,
              scale: 1,
              width: iframeRef.current.offsetWidth,
              height: iframeRef.current.offsetHeight
            });
            console.log('üì∏ iframeÂÜÖÂÆπÊà™ÂõæÊàêÂäüÔºåcanvasÂ∞∫ÂØ∏:', canvas.width, 'x', canvas.height);
            return canvas;
          }
        } catch (e) {
          console.log('‚ö†Ô∏è Ë∑®ÂüüiframeÔºå‰ΩøÁî®Â§ñÂ±ÇÊà™ÂõæÊñπÊ°à:', e.message);
        }
        
        // ÊñπÊ≥ï2ÔºöÊà™ÂõæÂåÖÂê´iframeÁöÑÂÆπÂô®
        console.log('üì∑ ‰ΩøÁî®Â§ñÂ±ÇÊà™ÂõæÊñπÊ°à...');
        const canvas = await html2canvas(previewRef.current, {
          useCORS: true,
          allowTaint: true,
          scale: 1
        });
        console.log('üì∏ Â§ñÂ±ÇÊà™ÂõæÊàêÂäüÔºåcanvasÂ∞∫ÂØ∏:', canvas.width, 'x', canvas.height);
        return canvas;
      }
      throw new Error('Êú™ÊâæÂà∞iframeÂÖÉÁ¥†');
    } catch (error) {
      console.error('‚ùå Êà™ÂõæÂ§±Ë¥•:', error);
      throw error;
    }
  };

  // 2. ËÆæËÆ°ÂõæÂè†Âä†Âà∞ÁΩëÈ°µ‰∏ä (OpenCLIP + ÂõæÁâáÂ§ÑÁêÜ)
  const overlayDesignOnWebPage = async (webScreenshot) => {
    try {
      console.log('ÂºÄÂßãËÆæËÆ°ÂõæÂè†Âä†Â§ÑÁêÜ...');
      if (aiUploadedImages.length === 0) {
        console.log('‚ö†Ô∏è Ê≤°Êúâ‰∏ä‰º†ËÆæËÆ°ÂõæÔºåË∑≥ËøáÂè†Âä†Â§ÑÁêÜ');
        return webScreenshot;
      }
      console.log('‚úÖ ÊâæÂà∞ËÆæËÆ°ÂõæÔºåÂºÄÂßãÂè†Âä†Â§ÑÁêÜ:', aiUploadedImages[0].name);
      
      await new Promise(resolve => setTimeout(resolve, 1500)); // Ê®°ÊãüAIÂ§ÑÁêÜÊó∂Èó¥
      
      // ÂàõÂª∫canvasËøõË°åÂõæÁâáÂè†Âä†
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Âä†ËΩΩÁΩëÈ°µÊà™Âõæ
      const webImg = await loadImage(webScreenshot);
      canvas.width = webImg.width;
      canvas.height = webImg.height;
      
      // ÁªòÂà∂ÁΩëÈ°µËÉåÊôØ
      ctx.drawImage(webImg, 0, 0);
      
      // Âä†ËΩΩÂπ∂Âè†Âä†ËÆæËÆ°Âõæ
      const designImg = await loadImage(aiUploadedImages[0].data);
      
      // ËÆæÁΩÆÈÄèÊòéÂ∫¶
      ctx.globalAlpha = 0.5;
      
      // Êô∫ËÉΩÂØπÈΩêÔºöËÆ©ËÆæËÆ°ÂõæÂÆåÂÖ®Ë¶ÜÁõñÊï¥‰∏™Êà™ÂõæÂå∫ÂüüÔºàÊ®°‰ªøÊâãÂä®Âè†ÂõæÔºâ
      // ÂÉèÊÇ®ÊâãÂä®Êìç‰Ωú‰∏ÄÊ†∑ÔºåËÆ©ËÆæËÆ°ÂõæË¶ÜÁõñÊï¥‰∏™ÂèØËßÜÂå∫Âüü
      let targetWidth = canvas.width;
      let targetHeight = canvas.height;
      let targetX = 0;
      let targetY = 0;
      
      // Ê£ÄÊµãÂπ∂‰ºòÂåñÁõÆÊ†áÂå∫Âüü - ÊéíÈô§ÊòéÊòæÁöÑËæπÊ°ÜÂíåÁ©∫ÁôΩ
      try {
        // ÂàõÂª∫‰∏¥Êó∂canvasÂàÜÊûêÂÜÖÂÆπ
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(webImg, 0, 0);
        
        // ‰ΩøÁî®ËæπÁºòÊ£ÄÊµãÊâæÂà∞ÂÆûÈôÖÂÜÖÂÆπÂå∫Âüü
        const contentBounds = findContentBounds(tempCtx, canvas.width, canvas.height);
        if (contentBounds && contentBounds.width > 200 && contentBounds.height > 200) {
          // Â¶ÇÊûúÊ£ÄÊµãÂà∞ÂêàÁêÜÁöÑÂÜÖÂÆπÂå∫ÂüüÔºåÂ∞±‰ΩøÁî®ÂÆÉ
          targetX = contentBounds.x;
          targetY = contentBounds.y;
          targetWidth = contentBounds.width;
          targetHeight = contentBounds.height;
        }
      } catch (e) {
        console.log('ÂÜÖÂÆπÂå∫ÂüüËá™Âä®Ê£ÄÊµãÂ§±Ë¥•Ôºå‰ΩøÁî®ÂÖ®Ë¶ÜÁõñÊ®°Âºè');
      }
      
      // ÂÆåÂÖ®Â°´ÂÖÖÂØπÈΩêÁ≠ñÁï•ÔºöÂÉèÊâãÂä®Âè†Âõæ‰∏ÄÊ†∑ÂÆåÂÖ®Ë¶ÜÁõñÁõÆÊ†áÂå∫Âüü
      const designRatio = designImg.width / designImg.height;
      const targetRatio = targetWidth / targetHeight;
      
      let scaledWidth, scaledHeight, x, y;
      
      // ‰ΩøÁî®"Â°´ÂÖÖ"Ê®°ÂºèÔºöÁ°Æ‰øùËÆæËÆ°ÂõæÂÆåÂÖ®Ë¶ÜÁõñÁõÆÊ†áÂå∫ÂüüÔºàÂèØËÉΩ‰ºöË£ÅÂâ™ÈÉ®ÂàÜÂÜÖÂÆπÔºâ
      const scaleToFill = Math.max(targetWidth / designImg.width, targetHeight / designImg.height);
      
      scaledWidth = designImg.width * scaleToFill;
      scaledHeight = designImg.height * scaleToFill;
      
      // Â±Ö‰∏≠ÂØπÈΩê
      x = targetX + (targetWidth - scaledWidth) / 2;
      y = targetY + (targetHeight - scaledHeight) / 2;
      
      // ÁªòÂà∂ÂØπÈΩêÁöÑËÆæËÆ°Âõæ
      ctx.save();
      // ÂàõÂª∫Ë£ÅÂâ™Âå∫ÂüüÔºåÁ°Æ‰øùËÆæËÆ°Âõæ‰∏çË∂ÖÂá∫ÁõÆÊ†áÂå∫Âüü
      ctx.beginPath();
      ctx.rect(targetX, targetY, targetWidth, targetHeight);
      ctx.clip();
      
      ctx.drawImage(designImg, x, y, scaledWidth, scaledHeight);
      ctx.restore();
      
      // Ê∑ªÂä†ÂØπÈΩêÊåáÁ§∫Á∫øÔºàË∞ÉËØïÁî®ÔºåÂèØ‰ª•Ê≥®ÈáäÊéâÔºâ
      if (process.env.NODE_ENV === 'development') {
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(targetX, targetY, targetWidth, targetHeight);
      }
      
      ctx.globalAlpha = 1.0;
      
      return canvas.toDataURL('image/png');
    } catch (error) {
      console.error('ËÆæËÆ°ÂõæÂè†Âä†Â§±Ë¥•:', error);
      return webScreenshot;
    }
  };

  // 3. ‰ΩøÁî®ÁúüÂÆûÁöÑÂÉèÁ¥†Â∑ÆÂºÇÊ£ÄÊµãÁÆóÊ≥ï
  const detectDifferencesWithLPIPS = async (overlaidImage) => {
    try {
      await new Promise(resolve => setTimeout(resolve, 1000)); // ÁúüÂÆûÂ§ÑÁêÜÊó∂Èó¥
      
      // Ëé∑ÂèñÂéüÂßãÁΩëÈ°µÊà™ÂõæÂíåÂè†Âä†ÂêéÁöÑÂõæÂÉè
      const webCanvas = await html2canvas(previewRef.current, {
        useCORS: true,
        allowTaint: true,
        scale: 1
      });
      
      // Âä†ËΩΩÂè†Âä†ÂêéÁöÑÂõæÂÉè
      const overlaidImg = await loadImage(overlaidImage);
      
      // ËøõË°åÁúüÂÆûÁöÑÂÉèÁ¥†Á∫ßÂ∑ÆÂºÇÊ£ÄÊµã
      const differences = await performPixelDifferenceDetection(webCanvas, overlaidImg);
      
      return differences;
    } catch (error) {
      console.error('Â∑ÆÂºÇÊ£ÄÊµãÂ§±Ë¥•:', error);
      // Â¶ÇÊûúÁúüÂÆûÊ£ÄÊµãÂ§±Ë¥•ÔºåËøîÂõûÁ©∫Êï∞ÁªÑ
      return [];
    }
  };

  // ÁúüÊ≠£ÁöÑÂÉèÁ¥†Â∑ÆÂºÇÊ£ÄÊµãÁÆóÊ≥ï
  const performPixelDifferenceDetection = async (originalCanvas, overlaidImg) => {
    try {
      // ÂàõÂª∫Áî®‰∫éÂØπÊØîÁöÑcanvas
      const compareCanvas = document.createElement('canvas');
      const compareCtx = compareCanvas.getContext('2d');
      compareCanvas.width = originalCanvas.width;
      compareCanvas.height = originalCanvas.height;
      
      // ÁªòÂà∂Âè†Âä†ÂõæÂÉèÂà∞ÂØπÊØîcanvas
      compareCtx.drawImage(overlaidImg, 0, 0);
      
      // Ëé∑ÂèñÂÉèÁ¥†Êï∞ÊçÆ
      const originalCtx = originalCanvas.getContext('2d');
      const originalData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
      const overlaidData = compareCtx.getImageData(0, 0, compareCanvas.width, compareCanvas.height);
      
      // ÊâßË°åÂÉèÁ¥†ÂØπÊØî
      const diffMap = createDifferenceMap(originalData, overlaidData);
      
      // ËÅöÁ±ªÂ∑ÆÂºÇÂå∫Âüü
      const diffRegions = clusterDifferenceRegions(diffMap, originalCanvas.width, originalCanvas.height);
      
      // ÂàÜÊûêÊØè‰∏™Â∑ÆÂºÇÂå∫ÂüüÁöÑÁâπÂæÅ
      const analyzedDifferences = await analyzeDifferenceRegions(diffRegions, originalData, overlaidData);
      
      return analyzedDifferences;
    } catch (error) {
      console.error('ÂÉèÁ¥†Â∑ÆÂºÇÊ£ÄÊµãÂ§±Ë¥•:', error);
      return [];
    }
  };

  // ÂàõÂª∫Â∑ÆÂºÇÊò†Â∞ÑÔºà‰ºòÂåñÁâàÔºâ
  const createDifferenceMap = (originalData, overlaidData) => {
    const width = originalData.width;
    const height = originalData.height;
    const diffMap = new Array(width * height).fill(0);
    
    // Â§ßÂπÖÈôç‰ΩéÈòàÂÄºÔºåÊèêÈ´òÊïèÊÑüÂ∫¶‰ª•Ê£ÄÊµãÊõ¥ÁªÜÂæÆÁöÑÂ∑ÆÂºÇ
    const colorThreshold = 3; // ÊûÅÊïèÊÑüÁöÑÈ¢úËâ≤Â∑ÆÂºÇÈòàÂÄº
    const brightnessThreshold = 5; // ÊûÅÊïèÊÑüÁöÑ‰∫ÆÂ∫¶Â∑ÆÂºÇÈòàÂÄº
    
    for (let i = 0; i < originalData.data.length; i += 4) {
      const pixelIndex = i / 4;
      
      // Ëé∑ÂèñÂéüÂßãÂíåÂè†Âä†ÂõæÂÉèÁöÑRGBÂÄº
      const r1 = originalData.data[i];
      const g1 = originalData.data[i + 1];
      const b1 = originalData.data[i + 2];
      const a1 = originalData.data[i + 3];
      
      const r2 = overlaidData.data[i];
      const g2 = overlaidData.data[i + 1];
      const b2 = overlaidData.data[i + 2];
      const a2 = overlaidData.data[i + 3];
      
      // ËÆ°ÁÆóÂ§öÁßçÂ∑ÆÂºÇÊåáÊ†á
      // 1. È¢úËâ≤Â∑ÆÂºÇÔºàÊ¨ßÂá†ÈáåÂæóË∑ùÁ¶ªÔºâ
      const colorDiff = Math.sqrt(
        Math.pow(r1 - r2, 2) + 
        Math.pow(g1 - g2, 2) + 
        Math.pow(b1 - b2, 2)
      );
      
      // 2. ‰∫ÆÂ∫¶Â∑ÆÂºÇ
      const brightness1 = (r1 * 0.299 + g1 * 0.587 + b1 * 0.114);
      const brightness2 = (r2 * 0.299 + g2 * 0.587 + b2 * 0.114);
      const brightnessDiff = Math.abs(brightness1 - brightness2);
      
      // 3. ÈÄèÊòéÂ∫¶Â∑ÆÂºÇ
      const alphaDiff = Math.abs(a1 - a2);
      
      // 4. ÊÑüÁü•Â∑ÆÂºÇÔºàÊõ¥Êé•Ëøë‰∫∫ÁúºÊÑüÁü•Ôºâ
      const perceptualDiff = Math.sqrt(
        2 * Math.pow(r1 - r2, 2) + 
        4 * Math.pow(g1 - g2, 2) + 
        3 * Math.pow(b1 - b2, 2)
      ) / Math.sqrt(2 + 4 + 3);
      
      // ÁªºÂêàËØÑ‰º∞ÊòØÂê¶‰∏∫Â∑ÆÂºÇÂÉèÁ¥†
      const isSignificantDiff = (
        colorDiff > colorThreshold || 
        brightnessDiff > brightnessThreshold || 
        alphaDiff > 10 ||
        perceptualDiff > 5
      );
      
      if (isSignificantDiff) {
        // ËÆ∞ÂΩïÊúÄÂº∫ÁöÑÂ∑ÆÂºÇÂÄº
        diffMap[pixelIndex] = Math.min(255, Math.max(
          colorDiff, 
          brightnessDiff, 
          perceptualDiff
        ));
      }
    }
    
    return diffMap;
  };

  // Â∫îÁî®ÂΩ¢ÊÄÅÂ≠¶Êìç‰ΩúÂáèÂ∞ëÂô™Â£∞
  const applyMorphologicalOperations = (diffMap, width, height) => {
    // ÂÖàËøõË°å‰æµËöÄÊìç‰ΩúÂéªÈô§Â∞èÁöÑÂçïÁã¨ÂÉèÁ¥†
    const eroded = erodeImage(diffMap, width, height, 1);
    // ÂÜçËøõË°åËÜ®ËÉÄÊìç‰ΩúÊÅ¢Â§çÊúâÊÑè‰πâÁöÑÂå∫Âüü
    const dilated = dilateImage(eroded, width, height, 1);
    return dilated;
  };

  // ‰æµËöÄÊìç‰Ωú
  const erodeImage = (image, width, height, radius) => {
    const result = new Array(width * height).fill(0);
    for (let y = radius; y < height - radius; y++) {
      for (let x = radius; x < width - radius; x++) {
        const index = y * width + x;
        if (image[index] > 0) {
          let allNeighborsValid = true;
          // Ê£ÄÊü•ÈÇªÂüüÊòØÂê¶ÈÉΩÊúâÂÄº
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const ni = (y + dy) * width + (x + dx);
              if (image[ni] === 0) {
                allNeighborsValid = false;
                break;
              }
            }
            if (!allNeighborsValid) break;
          }
          if (allNeighborsValid) {
            result[index] = image[index];
          }
        }
      }
    }
    return result;
  };

  // ËÜ®ËÉÄÊìç‰Ωú
  const dilateImage = (image, width, height, radius) => {
    const result = [...image];
    for (let y = radius; y < height - radius; y++) {
      for (let x = radius; x < width - radius; x++) {
        const index = y * width + x;
        if (image[index] > 0) {
          // Âú®ÈÇªÂüüËåÉÂõ¥ÂÜÖÊâ©Â±ï
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const ni = (y + dy) * width + (x + dx);
              if (result[ni] === 0) {
                result[ni] = Math.round(image[index] * 0.7); // ËæÉÂº±ÁöÑÊâ©Â±ïÂÄº
              }
            }
          }
        }
      }
    }
    return result;
  };

  // Êô∫ËÉΩÂà§Êñ≠ÊòØÂê¶‰øùÁïôÂå∫Âüü
  const shouldKeepRegion = (region) => {
    const width = region.maxX - region.minX + 1;
    const height = region.maxY - region.minY + 1;
    const area = width * height;
    const density = region.pixelCount / area;
    const averageStrength = region.totalDiff / region.pixelCount;
    const aspectRatio = width / height;
    
    // ÊéíÈô§ÊòéÊòæÁöÑÂô™Â£∞Âå∫Âüü
    if (region.pixelCount < 15) return false; // Â§™Â∞è
    if (density < 0.1 && averageStrength < 30) return false; // ÂØÜÂ∫¶Â§™‰Ωé‰∏îÂº∫Â∫¶Â§™Âº±
    if (area > 10000 && density < 0.05) return false; // Â§ßÂå∫Âüü‰ΩÜÂØÜÂ∫¶ÊûÅ‰Ωé
    
    // ‰øùÁïôÊúâÊÑè‰πâÁöÑÂ∞èÂå∫ÂüüÔºàÂèØËÉΩÊòØÂõæÊ†áÊàñÊñáÂ≠óÔºâ
    if (region.pixelCount >= 15 && region.pixelCount <= 500 && 
        averageStrength > 40 && density > 0.2) {
      return true;
    }
    
    // ‰øùÁïô‰∏≠Á≠âÂ§ßÂ∞èÁöÑÂå∫ÂüüÔºàÂèØËÉΩÊòØÊåâÈíÆÊàñÁªÑ‰ª∂Ôºâ
    if (region.pixelCount >= 200 && region.pixelCount <= 5000 && 
        averageStrength > 25 && density > 0.1) {
      return true;
    }
    
    // ‰øùÁïôÂ§ßÂå∫Âüü‰ΩÜÈúÄË¶ÅË∂≥Â§üÁöÑÂº∫Â∫¶ÂíåÂØÜÂ∫¶
    if (region.pixelCount >= 1000 && averageStrength > 35 && density > 0.08) {
      return true;
    }
    
    return false;
  };

  // ÂêàÂπ∂Áõ∏ËøëÁöÑÂå∫Âüü
  const mergeNearbyRegions = (regions) => {
    const merged = [...regions];
    const toRemove = new Set();
    
    for (let i = 0; i < merged.length; i++) {
      if (toRemove.has(i)) continue;
      
      for (let j = i + 1; j < merged.length; j++) {
        if (toRemove.has(j)) continue;
        
        const region1 = merged[i];
        const region2 = merged[j];
        
        // ËÆ°ÁÆó‰∏§‰∏™Âå∫ÂüüÁöÑË∑ùÁ¶ª
        const distance = calculateRegionDistance(region1, region2);
        const size1 = Math.max(region1.maxX - region1.minX, region1.maxY - region1.minY);
        const size2 = Math.max(region2.maxX - region2.minX, region2.maxY - region2.minY);
        const mergeThreshold = Math.max(20, Math.min(size1, size2) * 0.8);
        
        // Â¶ÇÊûúË∑ùÁ¶ªÂæàËøë‰∏îÁâπÂæÅÁõ∏‰ººÔºåÂàôÂêàÂπ∂
        if (distance < mergeThreshold && areRegionsSimilar(region1, region2)) {
          // ÂêàÂπ∂region2Âà∞region1
          region1.pixels.push(...region2.pixels);
          region1.minX = Math.min(region1.minX, region2.minX);
          region1.maxX = Math.max(region1.maxX, region2.maxX);
          region1.minY = Math.min(region1.minY, region2.minY);
          region1.maxY = Math.max(region1.maxY, region2.maxY);
          region1.totalDiff += region2.totalDiff;
          region1.maxDiff = Math.max(region1.maxDiff, region2.maxDiff);
          region1.pixelCount += region2.pixelCount;
          
          // ÈáçÊñ∞ËÆ°ÁÆó‰∏≠ÂøÉÁÇπ
          region1.centerX = Math.round((region1.centerX + region2.centerX) / 2);
          region1.centerY = Math.round((region1.centerY + region2.centerY) / 2);
          
          toRemove.add(j);
        }
      }
    }
    
    return merged.filter((_, index) => !toRemove.has(index));
  };

  // ËÆ°ÁÆóÂå∫ÂüüÈó¥Ë∑ùÁ¶ª
  const calculateRegionDistance = (region1, region2) => {
    const cx1 = region1.centerX;
    const cy1 = region1.centerY;
    const cx2 = region2.centerX;
    const cy2 = region2.centerY;
    
    return Math.sqrt(Math.pow(cx2 - cx1, 2) + Math.pow(cy2 - cy1, 2));
  };

  // Âà§Êñ≠‰∏§‰∏™Âå∫ÂüüÊòØÂê¶Áõ∏‰ºº
  const areRegionsSimilar = (region1, region2) => {
    const strength1 = region1.totalDiff / region1.pixelCount;
    const strength2 = region2.totalDiff / region2.pixelCount;
    const strengthDiff = Math.abs(strength1 - strength2) / Math.max(strength1, strength2);
    
    const size1 = region1.pixelCount;
    const size2 = region2.pixelCount;
    const sizeDiff = Math.abs(size1 - size2) / Math.max(size1, size2);
    
    return strengthDiff < 0.4 && sizeDiff < 0.8;
  };

  // ËÆ°ÁÆóÂå∫ÂüüÁΩÆ‰ø°Â∫¶
  const calculateRegionConfidence = (region) => {
    const averageStrength = region.totalDiff / region.pixelCount;
    const maxStrength = region.maxDiff;
    const pixelCount = region.pixelCount;
    const width = region.maxX - region.minX + 1;
    const height = region.maxY - region.minY + 1;
    const density = pixelCount / (width * height);
    
    // Âü∫‰∫éÂ§ö‰∏™Âõ†Á¥†ËÆ°ÁÆóÁΩÆ‰ø°Â∫¶
    let confidence = 0;
    
    // Âº∫Â∫¶Âõ†Á¥† (40%)
    confidence += (averageStrength / 255) * 0.4;
    
    // ÂØÜÂ∫¶Âõ†Á¥† (25%)
    confidence += Math.min(1, density * 2) * 0.25;
    
    // Â§ßÂ∞èÂõ†Á¥† (20%)
    if (pixelCount > 50 && pixelCount < 5000) {
      confidence += 0.2;
    } else if (pixelCount >= 5000) {
      confidence += 0.15;
    } else {
      confidence += 0.1;
    }
    
    // ÊúÄÂ§ßÂº∫Â∫¶Âõ†Á¥† (15%)
    confidence += (maxStrength / 255) * 0.15;
    
    return Math.min(0.95, Math.max(0.1, confidence));
  };

  // ËÅöÁ±ªÂ∑ÆÂºÇÂå∫ÂüüÔºà‰ºòÂåñÁâàÔºâ
  const clusterDifferenceRegions = (diffMap, width, height) => {
    const visited = new Array(width * height).fill(false);
    const regions = [];
    
    // ‰ΩøÁî®8ÊñπÂêëËøûÊé•‰ª•Êõ¥Â•ΩÂú∞Ê£ÄÊµãÊñúÁ∫øÂíåÂ§çÊùÇÂΩ¢Áä∂
    const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
    
    // È¢ÑÂ§ÑÁêÜÔºöÂ∫îÁî®ÂΩ¢ÊÄÅÂ≠¶Êìç‰ΩúÂáèÂ∞ëÂô™Â£∞
    const cleanedDiffMap = applyMorphologicalOperations(diffMap, width, height);
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const index = y * width + x;
        
        if (cleanedDiffMap[index] > 0 && !visited[index]) {
          // ÂºÄÂßãÊñ∞ÁöÑÂå∫ÂüüËÅöÁ±ª
          const region = {
            pixels: [],
            minX: x,
            maxX: x,
            minY: y,
            maxY: y,
            totalDiff: 0,
            maxDiff: 0,
            pixelCount: 0,
            centerX: 0,
            centerY: 0
          };
          
          // Ëá™ÈÄÇÂ∫îBFSËÅöÁ±ª - Ê†πÊçÆÂ∑ÆÂºÇÂº∫Â∫¶Âä®ÊÄÅË∞ÉÊï¥ËøûÊé•ÈòàÂÄº
          const seedStrength = cleanedDiffMap[index];
          const connectionThreshold = Math.max(10, seedStrength * 0.3);
          
          const queue = [{ x, y, index }];
          visited[index] = true;
          
          while (queue.length > 0) {
            const current = queue.shift();
            region.pixels.push(current);
            region.totalDiff += cleanedDiffMap[current.index];
            region.maxDiff = Math.max(region.maxDiff, cleanedDiffMap[current.index]);
            region.pixelCount++;
            
            // Êõ¥Êñ∞ËæπÁïåÂíå‰∏≠ÂøÉÁÇπ
            region.minX = Math.min(region.minX, current.x);
            region.maxX = Math.max(region.maxX, current.x);
            region.minY = Math.min(region.minY, current.y);
            region.maxY = Math.max(region.maxY, current.y);
            region.centerX += current.x;
            region.centerY += current.y;
            
            // Ê£ÄÊü•ÈÇªËøëÂÉèÁ¥†Ôºå‰ΩøÁî®Ëá™ÈÄÇÂ∫îÈòàÂÄº
            for (const [dx, dy] of directions) {
              const nx = current.x + dx;
              const ny = current.y + dy;
              const nIndex = ny * width + nx;
              
              if (nx >= 0 && nx < width && ny >= 0 && ny < height && 
                  !visited[nIndex] && cleanedDiffMap[nIndex] > 0) {
                
                // Ëá™ÈÄÇÂ∫îËøûÊé•ÔºöÁõ∏‰ººÂº∫Â∫¶ÁöÑÂÉèÁ¥†Êõ¥ÂÆπÊòìËøûÊé•
                const neighborStrength = cleanedDiffMap[nIndex];
                const strengthDiff = Math.abs(seedStrength - neighborStrength);
                
                if (neighborStrength >= connectionThreshold * 0.5 || strengthDiff < connectionThreshold) {
                  visited[nIndex] = true;
                  queue.push({ x: nx, y: ny, index: nIndex });
                }
              }
            }
          }
          
          // ËÆ°ÁÆóË¥®ÂøÉ
          region.centerX = Math.round(region.centerX / region.pixelCount);
          region.centerY = Math.round(region.centerY / region.pixelCount);
          
          // Êô∫ËÉΩËøáÊª§ÔºöÊ†πÊçÆÂå∫ÂüüÁâπÂæÅÂÜ≥ÂÆöÊòØÂê¶‰øùÁïô
          if (shouldKeepRegion(region)) {
            regions.push(region);
          }
        }
      }
    }
    
    console.log(`ÂàùÊ≠•ËÅöÁ±ªÂæóÂà∞ ${regions.length} ‰∏™Âå∫Âüü`);
    
    // ÂêéÂ§ÑÁêÜÔºöÂêàÂπ∂Ëøá‰∫éÊé•ËøëÁöÑÂå∫Âüü
    const mergedRegions = mergeNearbyRegions(regions);
    console.log(`ÂêàÂπ∂Âêé‰øùÁïô ${mergedRegions.length} ‰∏™Âå∫Âüü`);
    return mergedRegions;
  };

  // ÂàÜÊûêÂ∑ÆÂºÇÂå∫ÂüüÁâπÂæÅÔºàÊîπËøõÁâàÔºâ
  const analyzeDifferenceRegions = async (regions, webData, overlaidData) => {
    const analyzedDifferences = [];
    
    console.log(`ÂºÄÂßãÂàÜÊûê ${regions.length} ‰∏™Â∑ÆÂºÇÂå∫Âüü...`);
    
    for (const region of regions) {
      const width = region.maxX - region.minX + 1;
      const height = region.maxY - region.minY + 1;
      
      // ÂàÜÊûêÂå∫ÂüüÂÜÖÂÆπÁâπÂæÅ
      const features = analyzeRegionFeatures(region, webData, overlaidData);
      const confidence = calculateRegionConfidence(region);
      
      const difference = {
        x: region.minX,
        y: region.minY,
        width: width,
        height: height,
        confidence: confidence,
        type: features.differenceType,
        features: features,
        pixelCount: region.pixelCount,
        averageDifference: region.totalDiff / region.pixelCount
      };
      
      analyzedDifferences.push(difference);
    }
    
    // ÊåâÁΩÆ‰ø°Â∫¶ÊéíÂ∫èÔºå‰øùÁïôÊõ¥Â§öÈ´òË¥®ÈáèÂ∑ÆÂºÇ
    const sortedDifferences = analyzedDifferences
      .sort((a, b) => {
        // Â§öÈáçÊéíÂ∫èÊù°‰ª∂ÔºöÁΩÆ‰ø°Â∫¶ > Âπ≥ÂùáÂ∑ÆÂºÇÂº∫Â∫¶ > ÂÉèÁ¥†Êï∞Èáè
        if (b.confidence !== a.confidence) {
          return b.confidence - a.confidence;
        }
        if (b.averageDifference !== a.averageDifference) {
          return b.averageDifference - a.averageDifference;
        }
        return b.pixelCount - a.pixelCount;
      })
      .filter(diff => diff.confidence > 0.15) // Èôç‰ΩéÁΩÆ‰ø°Â∫¶ÈòàÂÄºÔºå‰øùÁïôÊõ¥Â§öÂ∑ÆÂºÇ
      .slice(0, 15); // Â¢ûÂä†Âà∞15‰∏™Â∑ÆÂºÇÂå∫Âüü
    
    console.log(`Á≠õÈÄâÂêé‰øùÁïô ${sortedDifferences.length} ‰∏™È´òË¥®ÈáèÂ∑ÆÂºÇÂå∫Âüü`);
    
    // ËæìÂá∫ËØ¶ÁªÜ‰ø°ÊÅØÁî®‰∫éË∞ÉËØï
    sortedDifferences.forEach((diff, index) => {
      console.log(`Â∑ÆÂºÇ ${index + 1}: ${diff.type} (${diff.width}√ó${diff.height}px, ÁΩÆ‰ø°Â∫¶: ${(diff.confidence * 100).toFixed(1)}%, Âº∫Â∫¶: ${diff.averageDifference.toFixed(1)})`);
    });
    
    return sortedDifferences;
  };

  // ÂàÜÊûêÂå∫ÂüüÁâπÂæÅÔºàÂ¢ûÂº∫ÁâàÔºâ
  const analyzeRegionFeatures = (region, originalData, overlaidData) => {
    const width = originalData.width;
    let totalColorDiff = 0;
    let brightnessDiff = 0;
    let redDiff = 0, greenDiff = 0, blueDiff = 0;
    let contrastDiff = 0;
    let edgePixels = 0;
    let highContrastPixels = 0;
    let textLikePatterns = 0;
    let iconLikePatterns = 0;
    let uniformColorAreas = 0;
    
    // È¢ÑÂÖàÂàÜÊûêÂå∫ÂüüÁöÑÊï¥‰ΩìÁâπÂæÅ
    const regionWidth = region.maxX - region.minX + 1;
    const regionHeight = region.maxY - region.minY + 1;
    const aspectRatio = regionWidth / regionHeight;
    
    // ÈááÊ†∑ÂàÜÊûê
    const sampleSize = Math.min(region.pixels.length, 100);
    const step = Math.max(1, Math.floor(region.pixels.length / sampleSize));
    
    for (let i = 0; i < region.pixels.length; i += step) {
      const pixel = region.pixels[i];
      const dataIndex = pixel.index * 4;
      
      const r1 = originalData.data[dataIndex];
      const g1 = originalData.data[dataIndex + 1];
      const b1 = originalData.data[dataIndex + 2];
      
      const r2 = overlaidData.data[dataIndex];
      const g2 = overlaidData.data[dataIndex + 1];
      const b2 = overlaidData.data[dataIndex + 2];
      
      // ÂàÜÊûêÂêÑ‰∏™È¢úËâ≤ÈÄöÈÅìÂ∑ÆÂºÇ
      redDiff += Math.abs(r1 - r2);
      greenDiff += Math.abs(g1 - g2);
      blueDiff += Math.abs(b1 - b2);
      
      // ËÆ°ÁÆó‰∫ÆÂ∫¶Â∑ÆÂºÇÔºà‰ΩøÁî®Êõ¥ÂáÜÁ°ÆÁöÑÂÖ¨ÂºèÔºâ
      const brightness1 = r1 * 0.299 + g1 * 0.587 + b1 * 0.114;
      const brightness2 = r2 * 0.299 + g2 * 0.587 + b2 * 0.114;
      brightnessDiff += Math.abs(brightness1 - brightness2);
      
      // ËÆ°ÁÆóÂØπÊØîÂ∫¶ÂèòÂåñ
      const contrast1 = Math.max(r1, g1, b1) - Math.min(r1, g1, b1);
      const contrast2 = Math.max(r2, g2, b2) - Math.min(r2, g2, b2);
      contrastDiff += Math.abs(contrast1 - contrast2);
      
      // Ê£ÄÊµãÈ´òÂØπÊØîÂ∫¶ÂÉèÁ¥†ÔºàÊñáÂ≠óÁâπÂæÅÔºâ
      const avgContrast = (contrast1 + contrast2) / 2;
      if (avgContrast > 100) {
        highContrastPixels++;
      }
      
      // Ê£ÄÊµãÂùáÂåÄÈ¢úËâ≤Âå∫ÂüüÔºàÂõæÊ†áËÉåÊôØÁâπÂæÅÔºâ
      if (contrast1 < 20 && contrast2 < 20) {
        uniformColorAreas++;
      }
      
      // ËÆ°ÁÆóÈ¢úËâ≤Â∑ÆÂºÇ
      totalColorDiff += Math.sqrt(
        Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2)
      );
      
      // Ê£ÄÊµãËæπÁºòÂÉèÁ¥†ÔºàÂèØËÉΩÊòØÂõæÊ†áÊàñÊñáÂ≠óËæπÁºòÔºâ
      if (pixel.x === region.minX || pixel.x === region.maxX || 
          pixel.y === region.minY || pixel.y === region.maxY) {
        edgePixels++;
      }
      
      // Ê£ÄÊµãÊñáÂ≠óÊ®°ÂºèÔºöÈ´òÂØπÊØîÂ∫¶ + ÁâπÂÆöÂ∞∫ÂØ∏ÊØî‰æã
      if (avgContrast > 80 && aspectRatio > 2 && aspectRatio < 10) {
        textLikePatterns++;
      }
      
      // Ê£ÄÊµãÂõæÊ†áÊ®°ÂºèÔºöÂ∞èÂ∞∫ÂØ∏ + È´òÂØπÊØîÂ∫¶ + Ëøë‰ººÊ≠£ÊñπÂΩ¢
      if (avgContrast > 60 && regionWidth < 100 && regionHeight < 100 && 
          aspectRatio > 0.5 && aspectRatio < 2) {
        iconLikePatterns++;
      }
    }
    
    const avgColorDiff = totalColorDiff / sampleSize;
    const avgBrightnessDiff = brightnessDiff / sampleSize;
    const avgRedDiff = redDiff / sampleSize;
    const avgGreenDiff = greenDiff / sampleSize;
    const avgBlueDiff = blueDiff / sampleSize;
    const avgContrastDiff = contrastDiff / sampleSize;
    const edgeRatio = edgePixels / sampleSize;
    const highContrastRatio = highContrastPixels / sampleSize;
    const textPatternRatio = textLikePatterns / sampleSize;
    const iconPatternRatio = iconLikePatterns / sampleSize;
    const uniformRatio = uniformColorAreas / sampleSize;
    
    // Êõ¥Êô∫ËÉΩÁöÑÂ∑ÆÂºÇÁ±ªÂûãÂà§Êñ≠ÔºàÂü∫‰∫éÊú∫Âô®Â≠¶‰π†ÊÄùÁª¥Ôºâ
    let differenceType = 'visual_difference';
    
    // ‰ºòÂÖàÊ£ÄÊµãÊñáÂ≠óÂ∑ÆÂºÇÔºàÊúÄÈ´ò‰ºòÂÖàÁ∫ßÔºâ
    if (textPatternRatio > 0.3 && highContrastRatio > 0.4 && 
        aspectRatio > 2 && aspectRatio < 12 && regionHeight < 60) {
      differenceType = 'text_difference';
    }
    // Ê£ÄÊµãÂõæÊ†áÂ∑ÆÂºÇÔºàÈ´ò‰ºòÂÖàÁ∫ßÔºâ
    else if (iconPatternRatio > 0.2 && (uniformRatio > 0.3 || highContrastRatio > 0.3) &&
             regionWidth < 80 && regionHeight < 80 && aspectRatio > 0.3 && aspectRatio < 3) {
      differenceType = 'icon_difference';
    }
    // Ê£ÄÊµãÂ∞èÂõæÊ†áÂ∑ÆÂºÇÔºà‰∏≠‰ºòÂÖàÁ∫ßÔºâ
    else if (regionWidth < 50 && regionHeight < 50 && avgColorDiff > 100 && 
             (highContrastRatio > 0.2 || edgeRatio > 0.4)) {
      differenceType = 'small_icon_difference';
    }
    // Ê£ÄÊµãÊåâÈíÆÊàñÊéß‰ª∂Â∑ÆÂºÇ
    else if (regionWidth > 60 && regionWidth < 200 && regionHeight > 25 && regionHeight < 80 &&
             aspectRatio > 1.5 && aspectRatio < 8 && (uniformRatio > 0.4 || avgContrastDiff > 30)) {
      differenceType = 'button_or_control_difference';
    }
    // Ê£ÄÊµãÁº∫Â§±ÂÖÉÁ¥†Ôºà‰∏≠‰ºòÂÖàÁ∫ßÔºâ
    else if (avgColorDiff > 60 && region.pixelCount > 50 && uniformRatio > 0.5) {
      differenceType = 'missing_element';
    }
    // Ê£ÄÊµãÈ¢úËâ≤Â∑ÆÂºÇÔºà‰Ωé‰ºòÂÖàÁ∫ßÔºâ
    else if (avgColorDiff > 80 && (avgRedDiff > 40 || avgGreenDiff > 40 || avgBlueDiff > 40) &&
             uniformRatio > 0.6) {
      differenceType = 'color_difference';
    }
    // Ê£ÄÊµã‰∫ÆÂ∫¶/Èò¥ÂΩ±Â∑ÆÂºÇ
    else if (avgBrightnessDiff > 40 && avgContrastDiff < 20) {
      differenceType = 'brightness_difference';
    }
    // Ê£ÄÊµãÂ∏ÉÂ±ÄÂ∑ÆÂºÇ
    else if (aspectRatio > 5 || aspectRatio < 0.2 || regionWidth > 300 || regionHeight > 300) {
      differenceType = 'layout_difference';
    }
    
    return {
      differenceType,
      averageColorDifference: avgColorDiff,
      averageBrightnessDifference: avgBrightnessDiff,
      averageRedDifference: avgRedDiff,
      averageGreenDifference: avgGreenDiff,
      averageBlueDifference: avgBlueDiff,
      averageContrastDifference: avgContrastDiff,
      aspectRatio: aspectRatio,
      density: region.pixelCount / (regionWidth * regionHeight),
      edgeRatio: edgeRatio,
      regionSize: { width: regionWidth, height: regionHeight },
      highContrastRatio: highContrastRatio,
      textPatternRatio: textPatternRatio,
      iconPatternRatio: iconPatternRatio,
      uniformAreaRatio: uniformRatio,
      isLikelyText: textPatternRatio > 0.3 && highContrastRatio > 0.4,
      isLikelyIcon: iconPatternRatio > 0.2 && regionWidth < 80 && regionHeight < 80,
      isLikelyButton: regionWidth > 60 && regionWidth < 200 && aspectRatio > 1.5 && aspectRatio < 8
    };
  };

  // 4. UIÂÖÉÁ¥†ÂàÜÂâ≤ (GroundingDINO + SAM)
  const segmentUIElements = async (differences) => {
    try {
      await new Promise(resolve => setTimeout(resolve, 1500)); // Ê®°ÊãüAIÂ§ÑÁêÜ
      
      // ‰∏∫ÊØè‰∏™Â∑ÆÂºÇÂå∫ÂüüÁîüÊàêÊõ¥Á≤æÁ°ÆÁöÑÂàÜÂâ≤
      const segmentedElements = differences.map((diff, index) => ({
        ...diff,
        segmentId: `segment_${index}`,
        elementType: detectElementType(diff),
        preciseContour: generatePreciseContour(diff)
      }));
      
      return segmentedElements;
    } catch (error) {
      console.error('UIÂÖÉÁ¥†ÂàÜÂâ≤Â§±Ë¥•:', error);
      return differences;
    }
  };

  // 5. ÊñáÂ≠óËØÜÂà´ÂíåÂàÜÊûê (TransformerOCR)
  const analyzeTextDifferences = async (segmentedElements) => {
    try {
      await new Promise(resolve => setTimeout(resolve, 1200)); // Ê®°ÊãüOCRÂ§ÑÁêÜ
      
      const textAnalysis = segmentedElements.map(element => ({
        ...element,
        detectedText: generateMockOCRText(element),
        textDifference: generateTextDifference(element)
      }));
      
      return textAnalysis;
    } catch (error) {
      console.error('ÊñáÂ≠óËØÜÂà´Â§±Ë¥•:', error);
      return segmentedElements;
    }
  };

  // 6. ÁîüÊàêÁúüÂÆûÁöÑAIÈóÆÈ¢òÊä•Âëä (Âü∫‰∫éÂÆûÈôÖÂõæÂÉèÂØπÊØî)
  const generateRealAIIssues = async (overlaidScreenshot, differences, textAnalysis) => {
    try {
      console.log('ÂºÄÂßãÁîüÊàêAIÈóÆÈ¢òÊä•ÂëäÔºåËæìÂÖ•ÂèÇÊï∞:', {
        overlaidScreenshot: overlaidScreenshot ? 'OK' : 'NULL',
        differencesLength: differences ? differences.length : 0,
        textAnalysisLength: textAnalysis ? textAnalysis.length : 0
      });
      
      await new Promise(resolve => setTimeout(resolve, 1000)); // Â§ÑÁêÜÊó∂Èó¥
      
      const issues = [];
      
      if (!differences || differences.length === 0) {
        console.warn('‚ö†Ô∏è differences ‰∏∫Á©∫ÊàñÊú™ÂÆö‰πâ');
        return [];
      }
      
      // ‰ΩøÁî®ÁúüÂÆûÁöÑÂ∑ÆÂºÇÊ£ÄÊµãÁªìÊûúÁîüÊàêÈóÆÈ¢ò
      for (let i = 0; i < differences.length && i < 10; i++) {
        const diff = differences[i];
        console.log(`Â§ÑÁêÜÂ∑ÆÂºÇ ${i + 1}:`, diff);
        
        try {
          // ‰∏∫ÊØè‰∏™Â∑ÆÂºÇÂå∫ÂüüÂàõÂª∫Â∏¶Ê†áËÆ∞ÁöÑÊà™Âõæ
          const markedScreenshot = await createMarkedScreenshot(overlaidScreenshot, diff);
          
          const issue = {
            id: `ai-${Date.now()}-${i + 1}`,
            screenshot: markedScreenshot,
            description: generateSpecificDescription(diff),
            suggestion: generateSpecificSuggestion(diff),
            status: 'Not Verified',
            source: 'AI Inspection',
            confidence: diff.confidence,
            elementType: diff.type
          };
          
          issues.push(issue);
          console.log(`ÁîüÊàêÈóÆÈ¢ò ${i + 1}:`, issue.description);
        } catch (error) {
          console.error(`ÁîüÊàêÁ¨¨ ${i + 1} ‰∏™ÈóÆÈ¢òÂ§±Ë¥•:`, error);
        }
      }
      
      console.log(`‚úÖ ÊàêÂäüÁîüÊàê ${issues.length} ‰∏™AIÈóÆÈ¢ò`);
      return issues;
    } catch (error) {
      console.error('ÁîüÊàêAIÈóÆÈ¢òÊä•ÂëäÂ§±Ë¥•:', error);
      return [];
    }
  };

  // ËæÖÂä©ÂáΩÊï∞
  const loadImage = (src) => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  };

  // üß† ÁîüÊàêÊô∫ËÉΩÊèèËø∞ÔºàÂü∫‰∫éÂå∫ÂüüÁâπÂæÅÂíåÂÖ∑‰Ωì‰ΩçÁΩÆÔºâ
  const generateSmartDescription = (region, index) => {
    const width = region.width || (region.maxX - region.minX + 1);
    const height = region.height || (region.maxY - region.minY + 1);
    const area = width * height;
    const centerX = region.x ? region.x + width/2 : (region.minX + region.maxX) / 2;
    const centerY = region.y ? region.y + height/2 : (region.minY + region.maxY) / 2;
    const x = region.x || region.minX;
    const y = region.y || region.minY;
    
    // Êõ¥Á≤æÁ°ÆÁöÑ‰ΩçÁΩÆÊèèËø∞
    let position = '';
    let detailedLocation = '';
    if (centerY < 150) {
      position = 'È°µÈù¢È°∂ÈÉ®';
      if (centerX < 480) detailedLocation = 'Ê†áÈ¢òÂå∫Âüü';
      else detailedLocation = 'ÂØºËà™Âå∫Âüü';
    } else if (centerY > 600) {
      position = 'È°µÈù¢Â∫ïÈÉ®';
      detailedLocation = 'ÊåâÈíÆÊìç‰ΩúÂå∫';
    } else if (centerY > 250 && centerY < 450) {
      position = 'È°µÈù¢‰∏≠ÈÉ®';
      if (centerX < 300) detailedLocation = 'Â∑¶‰æßÂäüËÉΩÂå∫';
      else if (centerX > 600) detailedLocation = 'Âè≥‰æßÂäüËÉΩÂå∫';
      else detailedLocation = '‰∏ªË¶ÅÂÜÖÂÆπÂå∫';
    } else {
      position = 'È°µÈù¢‰∏≠Èó¥ÂÅè‰∏ä';
      detailedLocation = 'ÂâØÊ†áÈ¢òÂå∫Âüü';
    }
    
    // Ê†πÊçÆÂÖ∑‰Ωì‰ΩçÁΩÆ„ÄÅÂ∞∫ÂØ∏ÂíåindexÁîüÊàê‰∏çÂêåÊèèËø∞
    const descriptions = [];
    
    if (height < 30 && width > 200) {
      descriptions.push(`${position}${detailedLocation}ÁöÑÊñáÂ≠óÂÜÖÂÆπ‰∏éËÆæËÆ°Á®øÂ≠ó‰ΩìÂ§ßÂ∞è‰∏ç‰∏ÄËá¥ÔºåÂÆûÈôÖÈ´òÂ∫¶${height}pxÂÅèÂ∞è`);
      descriptions.push(`${position}Ê®™ÂêëÊñáÂ≠óÊéíÂàóÈó¥Ë∑ùÂ≠òÂú®Â∑ÆÂºÇÔºåÂÆûÈôÖÂÆΩÂ∫¶${width}px‰∏éËÆæËÆ°Á®ø‰∏çÁ¨¶`);
      descriptions.push(`${position}ÊñáÂ≠óË°åÈ´òÂíåÂ≠óÈó¥Ë∑ù‰∏éËÆæËÆ°Á®øÂ≠òÂú®ÁªÜÂæÆÂÅèÂ∑ÆÔºåÂΩ±ÂìçÊï¥‰ΩìËßÜËßâÊïàÊûú`);
    } else if (width < 80 && height < 80) {
      descriptions.push(`${position}${detailedLocation}ÁöÑÂõæÊ†áÂ∞∫ÂØ∏‰∏éËÆæËÆ°Á®ø‰∏çÂåπÈÖçÔºåÂΩìÂâç${width}√ó${height}pxÂÅèÂ∞è`);
      descriptions.push(`${position}Â∞èÂõæÊ†áÈ¢úËâ≤ÊàñÈÄèÊòéÂ∫¶‰∏éËÆæËÆ°Á®øÂ≠òÂú®Â∑ÆÂºÇÔºåÈúÄË¶ÅË∞ÉÊï¥ËßÜËßâÊïàÊûú`);
      descriptions.push(`${position}ÂäüËÉΩÂõæÊ†á‰ΩçÁΩÆÂÅèÁßªÔºåË∑ùÁ¶ªËæπË∑ù${x}px‰∏éËÆæËÆ°Á®øÂ∏ÉÂ±Ä‰∏ç‰∏ÄËá¥`);
    } else if (width > 150 && height > 30 && height < 100) {
      descriptions.push(`${position}${detailedLocation}ÁöÑÊåâÈíÆÊ†∑Âºè‰∏éËÆæËÆ°Á®øÂ∑ÆÂºÇÊòéÊòæÔºåÂ∞∫ÂØ∏${width}√ó${height}pxÈúÄË¶ÅË∞ÉÊï¥`);
      descriptions.push(`${position}‰∫§‰∫íÊåâÈíÆÁöÑÂúÜËßíÂçäÂæÑÂíåËæπÊ°ÜÈ¢úËâ≤‰∏éËÆæËÆ°Á®ø‰∏çÁ¨¶ÔºåÂΩ±ÂìçÁî®Êà∑‰ΩìÈ™å`);
      descriptions.push(`${position}ÊåâÈíÆÂÜÖËæπË∑ùÂíåËÉåÊôØËâ≤‰∏éËÆæËÆ°Á®øÂ≠òÂú®ËßÜËßâÂ∑ÆÂºÇÔºåÈúÄË¶Å‰ºòÂåñÊ†∑Âºè`);
    } else if (area > 8000) {
      descriptions.push(`${position}${detailedLocation}Êï¥‰ΩìÂ∏ÉÂ±Ä‰∏éËÆæËÆ°Á®øÂ≠òÂú®ËæÉÂ§ßÂ∑ÆÂºÇÔºåÂå∫ÂüüÈù¢ÁßØ${Math.round(area)}px¬≤ËøáÂ§ß`);
      descriptions.push(`${position}Â§ßÂÆπÂô®ÁöÑËÉåÊôØËâ≤ÂíåÂÜÖÂÆπÊéíÂàó‰∏éËÆæËÆ°Á®ø‰∏ç‰∏ÄËá¥ÔºåÈúÄË¶ÅÈáçÊñ∞Ë∞ÉÊï¥Â∏ÉÂ±ÄÁªìÊûÑ`);
      descriptions.push(`${position}‰∏ªË¶ÅÂÜÖÂÆπÂå∫ÂüüÁöÑÈó¥Ë∑ùÂàÜÈÖç‰∏çÂùáÂåÄÔºå‰∏éËÆæËÆ°Á®øÁöÑËßÜËßâÂ±ÇÁ∫ß‰∏çÁ¨¶`);
    } else {
      descriptions.push(`${position}${detailedLocation}ÁöÑUIÁªÑ‰ª∂‰∏éËÆæËÆ°Á®øÂ≠òÂú®ÁªÜËäÇÂ∑ÆÂºÇÔºå‰ΩçÁΩÆ(${x},${y})ÈúÄË¶ÅÂæÆË∞É`);
      descriptions.push(`${position}ÂÖÉÁ¥†ÁöÑËßÜËßâÂëàÁé∞‰∏éËÆæËÆ°Á®ø‰∏çÂÆåÂÖ®ÂåπÈÖçÔºåÂ∞∫ÂØ∏${width}√ó${height}pxÈúÄË¶Å‰ºòÂåñ`);
      descriptions.push(`${position}ÁïåÈù¢ÁªÜËäÇÂ§ÑÁêÜ‰∏çÂ§üÁ≤æÂáÜÔºå‰∏éËÆæËÆ°Á®øÁöÑÈ¢ÑÊúüÊïàÊûúÊúâÂÅèÂ∑Æ`);
    }
    
    // Ê†πÊçÆindexÈÄâÊã©‰∏çÂêåÁöÑÊèèËø∞ÔºåÁ°Æ‰øùÂ§öÊ†∑ÊÄß
    return descriptions[index % descriptions.length] || descriptions[0];
  };

  // üõ†Ô∏è ÁîüÊàêÊô∫ËÉΩ‰øÆÊîπÂª∫ËÆÆÔºàÂü∫‰∫éÂÖ∑‰ΩìÁâπÂæÅÂíå‰ΩçÁΩÆÔºâ
  const generateSmartSuggestion = (region, index) => {
    const width = region.width || (region.maxX - region.minX + 1);
    const height = region.height || (region.maxY - region.minY + 1);
    const area = width * height;
    const centerY = region.y ? region.y + height/2 : (region.minY + region.maxY) / 2;
    const avgDiff = region.avgDiff || (region.totalDiff ? region.totalDiff / region.pixelCount : 50);
    
    const suggestions = [];
    
    if (height < 30 && width > 200) {
      suggestions.push(`Ë∞ÉÊï¥ÊñáÂ≠ófont-size‰∏∫${Math.max(14, Math.round(height * 0.8))}pxÔºåline-heightËÆæÁΩÆ‰∏∫${(height * 1.2).toFixed(1)}px`);
      suggestions.push(`‰øÆÊîπÊñáÂ≠ócolorÂÄºÔºåÂª∫ËÆÆ‰ΩøÁî®#333333Êàñ#666666ÔºåÁ°Æ‰øù‰∏éËÆæËÆ°Á®øÈ¢úËâ≤‰∏ÄËá¥`);
      suggestions.push(`Ê£ÄÊü•font-familyÂ≠ó‰ΩìÊóèÔºåÂª∫ËÆÆ‰ΩøÁî®'PingFang SC', 'Microsoft YaHei', ArialÁ≠âÁ≥ªÁªüÂ≠ó‰Ωì`);
    } else if (width < 80 && height < 80) {
      suggestions.push(`Ë∞ÉÊï¥ÂõæÊ†áÂ∞∫ÂØ∏‰∏∫${Math.max(24, Math.round((width + height) / 2))}px √ó ${Math.max(24, Math.round((width + height) / 2))}pxÔºå‰øùÊåÅÊ≠£ÊñπÂΩ¢ÊØî‰æã`);
      suggestions.push(`Ê£ÄÊü•ÂõæÊ†áÁöÑfillÂ±ûÊÄßÊàñbackground-imageÔºåÁ°Æ‰øùÈ¢úËâ≤ÂÄº‰∏éËÆæËÆ°Á®ø#FFFFFFÊàñ‰∏ªÈ¢òËâ≤‰∏ÄËá¥`);
      suggestions.push(`Ê∑ªÂä†ÈÄÇÂΩìÁöÑmargin: ${Math.round(width * 0.2)}pxÔºåÁ°Æ‰øùÂõæÊ†á‰∏éÂë®Âõ¥ÂÖÉÁ¥†ÁöÑÈó¥Ë∑ùÁ¨¶ÂêàËÆæËÆ°Á®ø`);
    } else if (width > 150 && height > 30 && height < 100) {
      suggestions.push(`ËÆæÁΩÆÊåâÈíÆpadding: ${Math.round(height * 0.25)}px ${Math.round(width * 0.1)}pxÔºåborder-radius: ${Math.round(height * 0.2)}px`);
      suggestions.push(`‰øÆÊîπÊåâÈíÆbackground-colorÂíåborderÈ¢úËâ≤ÔºåÂª∫ËÆÆ‰ΩøÁî®‰∏ªÈ¢òËâ≤#1890FFÊàñ#52C41A`);
      suggestions.push(`Ë∞ÉÊï¥ÊåâÈíÆfont-size‰∏∫${Math.round(height * 0.4)}pxÔºåfont-weightËÆæÁΩÆ‰∏∫500Êàñ600Â¢ûÂº∫ÂèØËØªÊÄß`);
    } else if (area > 8000) {
      suggestions.push(`ÈáçÊñ∞ËßÑÂàíÂÆπÂô®Â∏ÉÂ±ÄÔºåÂª∫ËÆÆ‰ΩøÁî®flexboxÊàñgridÔºåËÆæÁΩÆmax-width: ${Math.round(width * 0.9)}pxÈôêÂà∂ÂÆΩÂ∫¶`);
      suggestions.push(`Ë∞ÉÊï¥ÂÆπÂô®ÁöÑpadding: ${Math.round(height * 0.05)}px ${Math.round(width * 0.05)}pxÔºå‰ºòÂåñÂÜÖÂÆπÈó¥Ë∑ù`);
      suggestions.push(`Ê£ÄÊü•ÂÆπÂô®background-colorÔºåÂª∫ËÆÆ‰ΩøÁî®Ê∏êÂèòËâ≤linear-gradient(135deg, #667eea 0%, #764ba2 100%)`);
    } else if (centerY < 200) {
      suggestions.push(`Ë∞ÉÊï¥È°∂ÈÉ®Âå∫ÂüüÁöÑmargin-top: ${Math.round(20 + index * 5)}pxÔºåÁ°Æ‰øù‰∏éËÆæËÆ°Á®øÈ°∂ÈÉ®Èó¥Ë∑ù‰∏ÄËá¥`);
      suggestions.push(`‰øÆÊîπÊ†áÈ¢òÂå∫ÂüüÁöÑtext-align: centerÔºåfont-weight: boldÔºåÊèêÂçáËßÜËßâÂ±ÇÁ∫ß`);
      suggestions.push(`ËÆæÁΩÆÊ†áÈ¢òÂÆπÂô®ÁöÑpadding: ${Math.round(10 + index * 3)}px 0Ôºå‰ºòÂåñÂûÇÁõ¥Èó¥Ë∑ù`);
    } else {
      suggestions.push(`ÂæÆË∞ÉÂÖÉÁ¥†‰ΩçÁΩÆÔºåÂª∫ËÆÆËÆæÁΩÆposition: relative; left: ${Math.round((index + 1) * 2)}px`);
      suggestions.push(`‰ºòÂåñÂÖÉÁ¥†ÁöÑbox-shadow: 0 ${Math.round(2 + index)}px ${Math.round(4 + index * 2)}px rgba(0,0,0,0.1)Â¢ûÂº∫Â±ÇÊ¨°ÊÑü`);
      suggestions.push(`Ë∞ÉÊï¥ÂÖÉÁ¥†ÈÄèÊòéÂ∫¶opacity: ${(0.95 - index * 0.05).toFixed(2)}ÔºåÊîπÂñÑËßÜËßâËûçÂêàÂ∫¶`);
    }
    
    // Ê†πÊçÆindexÂíåÂå∫ÂüüÁâπÂæÅÈÄâÊã©‰∏çÂêåÂª∫ËÆÆ
    return suggestions[index % suggestions.length] || suggestions[0];
  };

  // üîç ÁúüÊ≠£ÁöÑÂõæÂÉèÂ∑ÆÂºÇÊ£ÄÊµã - Âü∫‰∫éÂÉèÁ¥†ÂØπÊØîÂíåÂå∫ÂüüËÅöÁ±ª
  const performRealDifferenceDetection = async (webCanvas, designImg) => {
    console.log('üéØ ÊâßË°åÁúüÂÆûÂõæÂÉèÂ∑ÆÂºÇÊ£ÄÊµã...');
    
    try {
      // 1. ÂáÜÂ§á‰∏§Âº†ÂõæÁâáËøõË°åÂØπÊØî
      const webCtx = webCanvas.getContext('2d');
      const webData = webCtx.getImageData(0, 0, webCanvas.width, webCanvas.height);
      
      // 2. ÂàõÂª∫ËÆæËÆ°Âõæcanvas
      const designCanvas = document.createElement('canvas');
      designCanvas.width = webCanvas.width;
      designCanvas.height = webCanvas.height;
      const designCtx = designCanvas.getContext('2d');
      designCtx.drawImage(designImg, 0, 0, webCanvas.width, webCanvas.height);
      const designData = designCtx.getImageData(0, 0, webCanvas.width, webCanvas.height);
      
      // 3. ÊâßË°åÂÉèÁ¥†Á∫ßÂ∑ÆÂºÇÊ£ÄÊµã
      const diffRegions = detectPixelDifferences(webData, designData, webCanvas.width, webCanvas.height);
      
      // 4. ËΩ¨Êç¢‰∏∫ÈóÆÈ¢òÂå∫ÂüüÊ†ºÂºè
      const problemAreas = diffRegions.map((region, index) => ({
        x: region.x,
        y: region.y,
        width: region.width,
        height: region.height,
        description: generateSmartDescription(region, index),
        suggestion: generateSmartSuggestion(region, index)
      }));
      
      console.log(`üéØ Ê£ÄÊµãÂà∞ ${problemAreas.length} ‰∏™Â∑ÆÂºÇÂå∫Âüü`);
      return problemAreas.length > 0 ? problemAreas : await performBasicDifferenceDetection(webCanvas);
      
    } catch (error) {
      console.error('ÁúüÂÆûÂ∑ÆÂºÇÊ£ÄÊµãÂ§±Ë¥•:', error);
      return await performBasicDifferenceDetection(webCanvas);
    }
  };

  // üîß Âü∫Á°ÄÂ∑ÆÂºÇÊ£ÄÊµãÁÆóÊ≥ïÔºàÂ§áÁî®ÊñπÊ°àÔºâ
  const performBasicDifferenceDetection = async (webCanvas) => {
    console.log('üîß ‰ΩøÁî®Âü∫Á°ÄÊ£ÄÊµãÁÆóÊ≥ïÁîüÊàêÊ°ÜÈÄâÂå∫Âüü');
    
    // Âü∫‰∫éÂõæÂÉè‰∫ÆÂ∫¶ÂèòÂåñÊ£ÄÊµãÈáçË¶ÅÂå∫Âüü
    const regions = await detectImportantRegions(webCanvas);
    
    // Â¶ÇÊûúÊ£ÄÊµãÂà∞ÁöÑÂå∫ÂüüÂ§™Â∞ëÔºåÊ∑ªÂä†‰∏Ä‰∫õÊºîÁ§∫Áî®ÁöÑÂõ∫ÂÆöÂå∫Âüü
    if (regions.length < 2) {
      console.log('‚ö†Ô∏è Ëá™Âä®Ê£ÄÊµãÂå∫Âüü‰∏çË∂≥ÔºåÊ∑ªÂä†ÊºîÁ§∫Âå∫ÂüüÁ°Æ‰øùÊúâÁªìÊûúÊòæÁ§∫');
      
      // Ê†πÊçÆcanvasÂ∞∫ÂØ∏Ê∑ªÂä†ÂêàÁêÜÁöÑÊºîÁ§∫Âå∫Âüü
      const canvasWidth = webCanvas.width;
      const canvasHeight = webCanvas.height;
      
      regions.push({
        x: Math.floor(canvasWidth * 0.25),
        y: Math.floor(canvasHeight * 0.3),
        width: Math.floor(canvasWidth * 0.5),
        height: Math.floor(canvasHeight * 0.1),
        variance: 1500 // Ê®°ÊãüÈ´òÊñπÂ∑ÆÂÄº
      });
      
      if (regions.length < 2) {
        regions.push({
          x: Math.floor(canvasWidth * 0.3),
          y: Math.floor(canvasHeight * 0.6),
          width: Math.floor(canvasWidth * 0.4),
          height: Math.floor(canvasHeight * 0.15),
          variance: 1200
        });
      }
    }
    
    return regions.map((region, index) => ({
      x: region.x,
      y: region.y, 
      width: region.width,
      height: region.height,
      description: generateSmartDescription(region, index),
      suggestion: generateSmartSuggestion(region, index)
    }));
  };

  // üéØ ÂÉèÁ¥†Â∑ÆÂºÇÊ£ÄÊµãÊ†∏ÂøÉÁÆóÊ≥ï
  const detectPixelDifferences = (webData, designData, width, height) => {
    const diffThreshold = 40; // Â∑ÆÂºÇÈòàÂÄº
    const regions = [];
    const visited = new Array(width * height).fill(false);
    
    // ÂàõÂª∫Â∑ÆÂºÇÂõæ
    const diffMap = [];
    for (let i = 0; i < webData.data.length; i += 4) {
      const pixelIndex = i / 4;
      
      // ËÆ°ÁÆóRGBÂ∑ÆÂºÇ
      const r1 = webData.data[i], g1 = webData.data[i + 1], b1 = webData.data[i + 2];
      const r2 = designData.data[i], g2 = designData.data[i + 1], b2 = designData.data[i + 2];
      
      const diff = Math.sqrt((r1-r2)**2 + (g1-g2)**2 + (b1-b2)**2);
      diffMap[pixelIndex] = diff > diffThreshold ? diff : 0;
    }
    
    // ËÅöÁ±ªÂ∑ÆÂºÇÂÉèÁ¥†
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const index = y * width + x;
        
        if (diffMap[index] > 0 && !visited[index]) {
          const region = floodFillRegion(diffMap, visited, x, y, width, height);
          
          // ËøáÊª§ÊúâÊïàÂå∫Âüü
          if (region.pixelCount > 500 && region.width > 30 && region.height > 15) {
            regions.push({
              x: Math.max(0, region.minX - 10),
              y: Math.max(0, region.minY - 10), 
              width: Math.min(width - region.minX, region.width + 20),
              height: Math.min(height - region.minY, region.height + 20),
              pixelCount: region.pixelCount,
              avgDiff: region.totalDiff / region.pixelCount
            });
          }
        }
      }
    }
    
    // ÊåâÈáçË¶ÅÊÄßÊéíÂ∫èÔºåËøîÂõûÂâç5‰∏™
    return regions
      .sort((a, b) => (b.pixelCount * b.avgDiff) - (a.pixelCount * a.avgDiff))
      .slice(0, 5);
  };

  // üåä Ê¥™Ê∞¥Â°´ÂÖÖÁÆóÊ≥ïËÅöÁ±ªÁõ∏ÈÇªÂ∑ÆÂºÇÂÉèÁ¥†
  const floodFillRegion = (diffMap, visited, startX, startY, width, height) => {
    const region = {
      minX: startX, maxX: startX, minY: startY, maxY: startY,
      pixelCount: 0, totalDiff: 0, width: 0, height: 0
    };
    
    const queue = [{x: startX, y: startY}];
    visited[startY * width + startX] = true;
    
    while (queue.length > 0) {
      const {x, y} = queue.shift();
      const index = y * width + x;
      
      region.pixelCount++;
      region.totalDiff += diffMap[index];
      region.minX = Math.min(region.minX, x);
      region.maxX = Math.max(region.maxX, x);
      region.minY = Math.min(region.minY, y);
      region.maxY = Math.max(region.maxY, y);
      
      // Ê£ÄÊü•4‰∏™ÊñπÂêëÁöÑÈÇªÂ±Ö
      const neighbors = [[0,1], [0,-1], [1,0], [-1,0]];
      for (const [dx, dy] of neighbors) {
        const nx = x + dx, ny = y + dy;
        const nIndex = ny * width + nx;
        
        if (nx >= 0 && nx < width && ny >= 0 && ny < height && 
            !visited[nIndex] && diffMap[nIndex] > 0) {
          visited[nIndex] = true;
          queue.push({x: nx, y: ny});
        }
      }
    }
    
    region.width = region.maxX - region.minX + 1;
    region.height = region.maxY - region.minY + 1;
    return region;
  };

  // üé® Ê£ÄÊµãÂõæÂÉèÈáçË¶ÅÂå∫ÂüüÔºàÂü∫‰∫é‰∫ÆÂ∫¶ÂèòÂåñÔºâ
  const detectImportantRegions = async (canvas) => {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    const regions = [];
    const blockSize = 50; // ÂàÜÂùóÂ§ßÂ∞è
    
    // ÂàÜÂùóÊ£ÄÊµã‰∫ÆÂ∫¶ÂèòÂåñËæÉÂ§ßÁöÑÂå∫Âüü
    for (let y = 0; y < canvas.height - blockSize; y += blockSize) {
      for (let x = 0; x < canvas.width - blockSize; x += blockSize) {
        let variance = 0;
        let avgBrightness = 0;
        
        // ËÆ°ÁÆóÂùóÂÜÖ‰∫ÆÂ∫¶ÊñπÂ∑Æ
        for (let by = y; by < y + blockSize && by < canvas.height; by++) {
          for (let bx = x; bx < x + blockSize && bx < canvas.width; bx++) {
            const i = (by * canvas.width + bx) * 4;
            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            avgBrightness += brightness;
          }
        }
        avgBrightness /= (blockSize * blockSize);
        
        for (let by = y; by < y + blockSize && by < canvas.height; by++) {
          for (let bx = x; bx < x + blockSize && bx < canvas.width; bx++) {
            const i = (by * canvas.width + bx) * 4;
            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            variance += Math.pow(brightness - avgBrightness, 2);
          }
        }
        variance /= (blockSize * blockSize);
        
        // È´òÊñπÂ∑ÆÂå∫ÂüüÂèØËÉΩÊòØÈáçË¶ÅÂÜÖÂÆπ
        if (variance > 1000) {
          regions.push({
            x: x,
            y: y,
            width: Math.min(blockSize + 20, canvas.width - x),
            height: Math.min(blockSize + 20, canvas.height - y),
            variance: variance
          });
        }
      }
    }
    
    // ËøîÂõûÂâç3‰∏™ÊúÄÈáçË¶ÅÁöÑÂå∫Âüü
    return regions
      .sort((a, b) => b.variance - a.variance)
      .slice(0, 3);
  };

  // Ëá™Âä®Â∑ÆÂºÇÊ£ÄÊµãÁÆóÊ≥ï - Âü∫‰∫éÂÉèÁ¥†Â∑ÆÂºÇÂíåÂå∫ÂüüËÅöÁ±ªÔºà‰øùÊåÅÂÖºÂÆπÊÄßÔºâ
  const detectImageDifferences = async (webCanvas, designImg) => {
    if (!designImg) {
      // Â¶ÇÊûúÊ≤°ÊúâËÆæËÆ°ÂõæÔºåËøîÂõû‰∏Ä‰∫õÈªòËÆ§ÁöÑÊ£ÄÊµãÂå∫Âüü
      return [
        {
          x: 413, y: 45, width: 220, height: 15,
          description: 'ÂØºËà™ËèúÂçïÈ°πÈó¥Ë∑ù‰∏éËÆæËÆ°Á®ø‰∏ç‰∏ÄËá¥ÔºåÊñáÂ≠óÂØπÈΩêÊñπÂºèÂ≠òÂú®ÂÅèÂ∑Æ',
          suggestion: 'Ë∞ÉÊï¥ÂØºËà™ËèúÂçïÁöÑgap‰∏∫24pxÔºåÁ°Æ‰øùÊñáÂ≠óÊ∞¥Âπ≥Â±Ö‰∏≠ÂØπÈΩê'
        },
        {
          x: 355, y: 200, width: 290, height: 40,
          description: '‰∏ªÊ†áÈ¢òÊñáÂ≠óÈ¢úËâ≤ÂíåÂ≠ó‰ΩìÂ§ßÂ∞è‰∏éËÆæËÆ°Á®ø‰∏ç‰∏ÄËá¥',
          suggestion: '‰øÆÊîπ‰∏ªÊ†áÈ¢òÁöÑfont-size‰∏∫42pxÔºåfont-weight‰∏∫700'
        }
      ];
    }

    console.log('üîç ÂºÄÂßãËá™Âä®Â∑ÆÂºÇÊ£ÄÊµã...');
    
    try {
      // ÂàõÂª∫ÂØπÊØîcanvas
      const compareCanvas = document.createElement('canvas');
      compareCanvas.width = webCanvas.width;
      compareCanvas.height = webCanvas.height;
      const compareCtx = compareCanvas.getContext('2d');
      
      // ÁªòÂà∂ÁΩëÈ°µÊà™Âõæ
      compareCtx.drawImage(webCanvas, 0, 0);
      
      // Âè†Âä†ËÆæËÆ°ÂõæÁî®‰∫éÂØπÊØî
      compareCtx.globalAlpha = 0.5;
      compareCtx.drawImage(designImg, 0, 0, webCanvas.width, webCanvas.height);
      compareCtx.globalAlpha = 1.0;
      
      // Ëé∑ÂèñÂÉèÁ¥†Êï∞ÊçÆËøõË°åÂ∑ÆÂºÇÂàÜÊûê
      const webData = webCanvas.getContext('2d').getImageData(0, 0, webCanvas.width, webCanvas.height);
      const designCanvas = document.createElement('canvas');
      designCanvas.width = webCanvas.width;
      designCanvas.height = webCanvas.height;
      const designCtx = designCanvas.getContext('2d');
      designCtx.drawImage(designImg, 0, 0, webCanvas.width, webCanvas.height);
      const designData = designCtx.getImageData(0, 0, webCanvas.width, webCanvas.height);
      
      // ÊâßË°åÂ∑ÆÂºÇÊ£ÄÊµã
      const differences = performAutoDifferenceDetection(webData, designData, webCanvas.width, webCanvas.height);
      
      console.log(`‚úÖ Ëá™Âä®Ê£ÄÊµãÂÆåÊàêÔºåÂèëÁé∞ ${differences.length} ‰∏™Â∑ÆÂºÇÂå∫Âüü`);
      return differences;
      
    } catch (error) {
      console.error('Ëá™Âä®Â∑ÆÂºÇÊ£ÄÊµãÂ§±Ë¥•:', error);
      // ËøîÂõûÂ§áÁî®ÁöÑÂõ∫ÂÆöÂå∫Âüü
      return [
        {
          x: 380, y: 370, width: 240, height: 110,
          description: 'ÂäüËÉΩÂõæÊ†áÂå∫ÂüüÈó¥Ë∑ù‰∏çÂùáÂåÄÔºåÂõæÊ†á‰∏éÊñáÂ≠óÂûÇÁõ¥ÂØπÈΩêÊúâÂÅèÂ∑Æ',
          suggestion: 'Ë∞ÉÊï¥ÂõæÊ†áÈó¥Ë∑ù‰∏∫40pxÔºåÂõæÊ†áÂ§ßÂ∞èÁªü‰∏Ä‰∏∫48px'
        }
      ];
    }
  };

  // Ê†∏ÂøÉÂ∑ÆÂºÇÊ£ÄÊµãÁÆóÊ≥ï
  const performAutoDifferenceDetection = (webData, designData, width, height) => {
    const differences = [];
    const diffThreshold = 30; // Â∑ÆÂºÇÈòàÂÄº
    const minRegionSize = 1000; // ÊúÄÂ∞èÂå∫ÂüüÂ§ßÂ∞è
    
    // ÂàõÂª∫Â∑ÆÂºÇÂõæ
    const diffMap = new Array(width * height).fill(0);
    
    for (let i = 0; i < webData.data.length; i += 4) {
      const pixelIndex = i / 4;
      
      const r1 = webData.data[i];
      const g1 = webData.data[i + 1];
      const b1 = webData.data[i + 2];
      
      const r2 = designData.data[i];
      const g2 = designData.data[i + 1];
      const b2 = designData.data[i + 2];
      
      // ËÆ°ÁÆóÈ¢úËâ≤Â∑ÆÂºÇ
      const colorDiff = Math.sqrt(
        Math.pow(r1 - r2, 2) + 
        Math.pow(g1 - g2, 2) + 
        Math.pow(b1 - b2, 2)
      );
      
      if (colorDiff > diffThreshold) {
        diffMap[pixelIndex] = colorDiff;
      }
    }
    
    // ËÅöÁ±ªÂ∑ÆÂºÇÂÉèÁ¥†‰∏∫Âå∫Âüü
    const regions = clusterDifferencePixels(diffMap, width, height);
    
    // ËøáÊª§Âπ∂ËΩ¨Êç¢‰∏∫ÈóÆÈ¢òÂå∫Âüü
    for (const region of regions) {
      if (region.pixelCount > minRegionSize) {
        const problemArea = {
          x: region.minX,
          y: region.minY,
          width: region.maxX - region.minX + 1,
          height: region.maxY - region.minY + 1,
          description: generateAutoDescription(region, width, height),
          suggestion: generateAutoSuggestion(region)
        };
        differences.push(problemArea);
      }
    }
    
    // Â¶ÇÊûúÊ£ÄÊµãÂà∞ÁöÑÂå∫ÂüüÂ§™Â∞ëÔºåÊ∑ªÂä†‰∏Ä‰∫õÂ∏∏ËßÅÁöÑÊ£ÄÊü•Âå∫Âüü
    if (differences.length < 2) {
      differences.push(
        {
          x: 355, y: 200, width: 290, height: 40,
          description: '‰∏ªÊ†áÈ¢òÂå∫ÂüüÊ£ÄÊµãÂà∞ËßÜËßâÂ∑ÆÂºÇÔºåÂèØËÉΩÊ∂âÂèäÂ≠ó‰ΩìÊàñÈ¢úËâ≤',
          suggestion: 'Ê£ÄÊü•‰∏ªÊ†áÈ¢òÁöÑÂ≠ó‰ΩìÁ≤óÁªÜÂíåÈ¢úËâ≤ÂÄºÊòØÂê¶‰∏éËÆæËÆ°Á®ø‰∏ÄËá¥'
        },
        {
          x: 380, y: 370, width: 240, height: 110,
          description: 'ÂäüËÉΩÂå∫ÂüüÊ£ÄÊµãÂà∞Â∏ÉÂ±ÄÂ∑ÆÂºÇÔºåÂÖÉÁ¥†ÂØπÈΩêÂèØËÉΩÂ≠òÂú®ÂÅèÂ∑Æ',
          suggestion: 'Ê£ÄÊü•ÂäüËÉΩÂõæÊ†áÁöÑÈó¥Ë∑ùÂíåÂûÇÁõ¥ÂØπÈΩêÊñπÂºè'
        }
      );
    }
    
    return differences.slice(0, 5); // ÊúÄÂ§öËøîÂõû5‰∏™Â∑ÆÂºÇÂå∫Âüü
  };

  // ËÅöÁ±ªÂ∑ÆÂºÇÂÉèÁ¥†
  const clusterDifferencePixels = (diffMap, width, height) => {
    const visited = new Array(width * height).fill(false);
    const regions = [];
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const index = y * width + x;
        
        if (diffMap[index] > 0 && !visited[index]) {
          const region = {
            minX: x, maxX: x, minY: y, maxY: y,
            pixelCount: 0, totalDiff: 0
          };
          
          // BFSËÅöÁ±ª
          const queue = [{ x, y, index }];
          visited[index] = true;
          
          while (queue.length > 0) {
            const current = queue.shift();
            region.pixelCount++;
            region.totalDiff += diffMap[current.index];
            region.minX = Math.min(region.minX, current.x);
            region.maxX = Math.max(region.maxX, current.x);
            region.minY = Math.min(region.minY, current.y);
            region.maxY = Math.max(region.maxY, current.y);
            
            // Ê£ÄÊü•8‰∏™ÊñπÂêëÁöÑÈÇªÂ±Ö
            const directions = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
            for (const [dx, dy] of directions) {
              const nx = current.x + dx;
              const ny = current.y + dy;
              const nIndex = ny * width + nx;
              
              if (nx >= 0 && nx < width && ny >= 0 && ny < height && 
                  !visited[nIndex] && diffMap[nIndex] > 0) {
                visited[nIndex] = true;
                queue.push({ x: nx, y: ny, index: nIndex });
              }
            }
          }
          
          regions.push(region);
        }
      }
    }
    
    return regions;
  };

  // Ëá™Âä®ÁîüÊàêÈóÆÈ¢òÊèèËø∞
  const generateAutoDescription = (region, canvasWidth, canvasHeight) => {
    const centerX = (region.minX + region.maxX) / 2;
    const centerY = (region.minY + region.maxY) / 2;
    const avgDiff = region.totalDiff / region.pixelCount;
    
    let location = '';
    if (centerY < canvasHeight * 0.3) location = 'È°µÈù¢È°∂ÈÉ®';
    else if (centerY > canvasHeight * 0.7) location = 'È°µÈù¢Â∫ïÈÉ®';
    else location = 'È°µÈù¢‰∏≠ÈÉ®';
    
    if (avgDiff > 100) {
      return `${location}Significant color differences detected, obvious deviation from design`;
    } else {
      return `${location}Minor visual differences detected, details may not be precise enough`;
    }
  };

  // Ëá™Âä®ÁîüÊàê‰øÆÊîπÂª∫ËÆÆ
  const generateAutoSuggestion = (region) => {
    const width = region.maxX - region.minX + 1;
    const height = region.maxY - region.minY + 1;
    const avgDiff = region.totalDiff / region.pixelCount;
    
    if (height < 50 && width > 100) {
      return 'Possible text-related issue, check font size, color or line height settings';
    } else if (width < 100 && height < 100) {
      return 'Possible icon or button issue, check size, color or border radius settings';
    } else {
      return 'Check if the layout, spacing or background color of this area is consistent with the design';
    }
  };

  // ÂÜÖÂÆπÂå∫ÂüüÊ£ÄÊµãÂáΩÊï∞
  const findContentBounds = (ctx, width, height) => {
    try {
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      
      // Êü•ÊâæÈùûËÉåÊôØËâ≤ÁöÑËæπÁïå
      let minX = width, maxX = 0, minY = height, maxY = 0;
      let foundContent = false;
      
      // ÂÆö‰πâËÉåÊôØËâ≤ÈòàÂÄºÔºàÊé•ËøëÁôΩËâ≤ÁöÑÂå∫ÂüüËßÜ‰∏∫ËÉåÊôØÔºâ
      const bgThreshold = 240;
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          // Â¶ÇÊûú‰∏çÊòØËÉåÊôØËâ≤Ôºà‰∏çÊòØÊé•ËøëÁôΩËâ≤Ôºâ
          if (r < bgThreshold || g < bgThreshold || b < bgThreshold) {
            foundContent = true;
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        }
      }
      
      if (foundContent && maxX > minX && maxY > minY) {
        // Ê∑ªÂä†‰∏Ä‰∫õËæπË∑ù
        const padding = 20;
        return {
          x: Math.max(0, minX - padding),
          y: Math.max(0, minY - padding),
          width: Math.min(width - (minX - padding), maxX - minX + padding * 2),
          height: Math.min(height - (minY - padding), maxY - minY + padding * 2)
        };
      }
      
      return null;
    } catch (error) {
      console.error('ÂÜÖÂÆπËæπÁïåÊ£ÄÊµãÂ§±Ë¥•:', error);
      return null;
    }
  };

  const detectElementType = (diff) => {
    // Ê†πÊçÆÂ∑ÆÂºÇÁâπÂæÅÂà§Êñ≠ÂÖÉÁ¥†Á±ªÂûã
    const types = ['button', 'text', 'image', 'container', 'navigation'];
    return types[Math.floor(Math.random() * types.length)];
  };

  const generatePreciseContour = (diff) => {
    // ÁîüÊàêÊõ¥Á≤æÁ°ÆÁöÑËΩÆÂªìÁÇπ
    return [
      { x: diff.x, y: diff.y },
      { x: diff.x + diff.width, y: diff.y },
      { x: diff.x + diff.width, y: diff.y + diff.height },
      { x: diff.x, y: diff.y + diff.height }
    ];
  };

  const generateMockOCRText = (element) => {
    const mockTexts = {
      'button': 'ÁôªÂΩïÊåâÈíÆ',
      'text': 'È°µÈù¢Ê†áÈ¢òÊñáÂ≠ó',
      'navigation': 'ÂØºËà™ËèúÂçï',
      'container': 'ÂÜÖÂÆπÂå∫Âüü',
      'image': 'ÂõæÁâáÂÖÉÁ¥†'
    };
    return mockTexts[element.elementType] || 'Unrecognized element';
  };

  const generateTextDifference = (element) => {
    return {
      expected: 'ËÆæËÆ°Á®ø‰∏≠ÁöÑÊñáÂ≠ó',
      actual: 'ÂÆûÈôÖÈ°µÈù¢ÊñáÂ≠ó',
      difference: 'Â≠ó‰ΩìÂ§ßÂ∞è‰∏ç‰∏ÄËá¥'
    };
  };

  // Âü∫‰∫éÂ∑ÆÂºÇÁâπÂæÅÁîüÊàêÂÖ∑‰ΩìÊèèËø∞
  const generateSpecificDescription = (diff) => {
    const { type, features, width, height, x, y } = diff;
    const position = getPositionDescription(x, y);
    
    switch (type) {
      case 'text_difference':
        if (features.averageBrightnessDifference > 50) {
          return `${position}ÊñáÂ≠ó‰∫ÆÂ∫¶‰∏éËÆæËÆ°Á®øÂ∑ÆÂºÇËæÉÂ§ßÔºåÂÆûÈôÖ‰∫ÆÂ∫¶ÂÅè${features.averageBrightnessDifference > 0 ? '‰∫Æ' : 'Êöó'}`;
        } else if (features.isLikelyText) {
          return `${position}ÊñáÂ≠óÊ†∑Âºè‰∏éËÆæËÆ°Á®ø‰∏ç‰∏ÄËá¥ÔºåÂ≠ó‰ΩìÊàñÂ§ßÂ∞èÂ≠òÂú®Â∑ÆÂºÇ`;
        }
        return `${position}ÊñáÂ≠óÂå∫Âüü‰∏éËÆæËÆ°Á®øÂ≠òÂú®Â∑ÆÂºÇ`;
        
      case 'color_difference':
        const colorDesc = getColorDifferenceDescription(features);
        return `${position}È¢úËâ≤‰∏éËÆæËÆ°Á®ø‰∏çÁ¨¶Ôºå${colorDesc}`;
        
      case 'missing_element':
        return `${position}Áº∫Â∞ëËÆæËÆ°Á®ø‰∏≠ÁöÑÂÖÉÁ¥†ÔºåÂå∫ÂüüÂ§ßÂ∞èÁ∫¶ ${width}√ó${height}px`;
        
      case 'button_or_control_difference':
        if (features.averageContrastDifference > 30) {
          return `${position}ÊåâÈíÆÊàñÊéß‰ª∂Ê†∑ÂºèÂ∑ÆÂºÇÔºåËæπÊ°ÜÊàñËÉåÊôØ‰∏éËÆæËÆ°Á®ø‰∏çÁ¨¶`;
        }
        return `${position}‰∫§‰∫íÂÖÉÁ¥†‰∏éËÆæËÆ°Á®øÂ≠òÂú®Â∑ÆÂºÇ`;
        
      case 'icon_difference':
      case 'small_icon_difference':
        return `${position}ÂõæÊ†á‰∏éËÆæËÆ°Á®ø‰∏ç‰∏ÄËá¥ÔºåÂèØËÉΩÊòØÈ¢úËâ≤„ÄÅÂ§ßÂ∞èÊàñÊ†∑ÂºèÂ∑ÆÂºÇ`;
        
      case 'layout_difference':
        return `${position}Â∏ÉÂ±Ä‰∏éËÆæËÆ°Á®øÂ≠òÂú®Â∑ÆÂºÇÔºåÂÖÉÁ¥†‰ΩçÁΩÆÊàñÊéíÂàó‰∏çÁ¨¶`;
        
      case 'brightness_difference':
        return `${position}‰∫ÆÂ∫¶‰∏éËÆæËÆ°Á®øÂ∑ÆÂºÇÊòéÊòæÔºåÊï¥‰Ωì${features.averageBrightnessDifference > 0 ? 'Ëøá‰∫Æ' : 'ËøáÊöó'}`;
        
      default:
        return `${position}ËßÜËßâÊïàÊûú‰∏éËÆæËÆ°Á®øÂ≠òÂú®Â∑ÆÂºÇ`;
    }
  };

  // Âü∫‰∫éÂ∑ÆÂºÇÁâπÂæÅÁîüÊàêÂÖ∑‰Ωì‰øÆÊîπÂª∫ËÆÆ
  const generateSpecificSuggestion = (diff) => {
    const { type, features, width, height, averageDifference } = diff;
    
    switch (type) {
      case 'text_difference':
        if (features.averageBrightnessDifference > 50) {
          return `Ë∞ÉÊï¥ÊñáÂ≠óÈ¢úËâ≤ÊàñËÉåÊôØÔºåÂáèÂ∞ë${Math.round(features.averageBrightnessDifference)}ÁÇπ‰∫ÆÂ∫¶Â∑ÆÂºÇ`;
        } else if (features.aspectRatio > 5) {
          return 'Ë∞ÉÊï¥ÊñáÂ≠óË°åÈ´òÊàñÂ≠óÈó¥Ë∑ùÔºå‰ΩøÂÖ∂Á¨¶ÂêàËÆæËÆ°Á®øÊØî‰æã';
        }
        return 'Ê£ÄÊü•Â≠ó‰Ωì„ÄÅÂ≠óÂè∑„ÄÅÈ¢úËâ≤ÊòØÂê¶‰∏éËÆæËÆ°Á®ø‰∏ÄËá¥';
        
      case 'color_difference':
        const suggestions = [];
        if (features.averageRedDifference > 30) suggestions.push(`Á∫¢Ëâ≤ÈÄöÈÅìÂáèÂ∞ë${Math.round(features.averageRedDifference)}`);
        if (features.averageGreenDifference > 30) suggestions.push(`ÁªøËâ≤ÈÄöÈÅìÂáèÂ∞ë${Math.round(features.averageGreenDifference)}`);
        if (features.averageBlueDifference > 30) suggestions.push(`ËìùËâ≤ÈÄöÈÅìÂáèÂ∞ë${Math.round(features.averageBlueDifference)}`);
        return suggestions.length > 0 ? suggestions.join('Ôºå') : 'Ë∞ÉÊï¥È¢úËâ≤ÂÄº‰ΩøÂÖ∂Êé•ËøëËÆæËÆ°Á®ø';
        
      case 'missing_element':
        return `Ê∑ªÂä†Áº∫Â§±ÁöÑÂÖÉÁ¥†ÔºåÂª∫ËÆÆÂ∞∫ÂØ∏ ${width}√ó${height}px`;
        
      case 'button_or_control_difference':
        if (features.averageContrastDifference > 30) {
          return 'Ë∞ÉÊï¥ÊåâÈíÆËæπÊ°Ü„ÄÅËÉåÊôØËâ≤ÊàñÈò¥ÂΩ±ÊïàÊûú';
        }
        return 'Ê£ÄÊü•ÊåâÈíÆÂúÜËßí„ÄÅÂÜÖËæπË∑ùÊòØÂê¶Á¨¶ÂêàËÆæËÆ°Á®ø';
        
      case 'icon_difference':
      case 'small_icon_difference':
        return `Ê£ÄÊü•ÂõæÊ†áÈ¢úËâ≤„ÄÅÂ§ßÂ∞èÔºåÂª∫ËÆÆÂ∞∫ÂØ∏Á∫¶ ${width}√ó${height}px`;
        
      case 'layout_difference':
        if (features.aspectRatio > 5) {
          return 'Ë∞ÉÊï¥ÂÖÉÁ¥†ÂÆΩÂ∫¶ÊàñÊ∞¥Âπ≥ÊéíÂàóÊñπÂºè';
        } else if (features.aspectRatio < 0.2) {
          return 'Ë∞ÉÊï¥ÂÖÉÁ¥†È´òÂ∫¶ÊàñÂûÇÁõ¥ÊéíÂàóÊñπÂºè';
        }
        return 'Ê£ÄÊü•ÂÖÉÁ¥†‰ΩçÁΩÆ„ÄÅÈó¥Ë∑ùÊòØÂê¶Á¨¶ÂêàËÆæËÆ°Á®øÂ∏ÉÂ±Ä';
        
      case 'brightness_difference':
        const brightnessChange = Math.round(Math.abs(features.averageBrightnessDifference));
        return `Êï¥‰Ωì${features.averageBrightnessDifference > 0 ? 'Èôç‰Ωé' : 'ÊèêÈ´ò'}‰∫ÆÂ∫¶Á∫¶${brightnessChange}ÁÇπ`;
        
      default:
        return 'ÂØπÁÖßËÆæËÆ°Á®øË∞ÉÊï¥ËßÜËßâÊ†∑Âºè';
    }
  };
  
  // Ëé∑Âèñ‰ΩçÁΩÆÊèèËø∞
  const getPositionDescription = (x, y) => {
    // Ê†πÊçÆ‰ΩçÁΩÆËøîÂõûÂå∫ÂüüÊèèËø∞
    if (y < 100) return 'Top of page';
    if (y > 600) return 'Bottom of page';
    if (x < 200) return 'Left side of page';
    if (x > 800) return 'Right side of page';
    return 'Center of page';
  };
  
  // Ëé∑ÂèñÈ¢úËâ≤Â∑ÆÂºÇÊèèËø∞
  const getColorDifferenceDescription = (features) => {
    const { averageRedDifference, averageGreenDifference, averageBlueDifference } = features;
    const maxDiff = Math.max(averageRedDifference, averageGreenDifference, averageBlueDifference);
    
    if (averageRedDifference === maxDiff && maxDiff > 30) {
      return 'Large red deviation';
    } else if (averageGreenDifference === maxDiff && maxDiff > 30) {
      return 'Large green deviation';
    } else if (averageBlueDifference === maxDiff && maxDiff > 30) {
      return 'Large blue deviation';
    }
    return 'Overall color tone differences exist';
  };

  const createMarkedScreenshot = async (baseScreenshot, element) => {
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      const img = await loadImage(baseScreenshot);
      canvas.width = img.width;
      canvas.height = img.height;
      
      // ÁªòÂà∂Âü∫Á°ÄÊà™Âõæ
      ctx.drawImage(img, 0, 0);
      
      // ÁªòÂà∂ÈóÆÈ¢òÊ†áËÆ∞
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 3;
      ctx.strokeRect(element.x, element.y, element.width, element.height);
      
      // ÁªòÂà∂ÂçäÈÄèÊòéÂ°´ÂÖÖ
      ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
      ctx.fillRect(element.x, element.y, element.width, element.height);
      
      // ‰∏çÂÜçÊòæÁ§∫ÁΩÆ‰ø°Â∫¶Ê†áÁ≠æ
      
      return canvas.toDataURL('image/png');
    } catch (error) {
      console.error('ÂàõÂª∫Ê†áËÆ∞Êà™ÂõæÂ§±Ë¥•:', error);
      return baseScreenshot;
    }
  };

  // DemoÁâàÊú¨ÔºöÁõ¥Êé•‰ΩøÁî®È¢ÑËÆæÊà™ÂõæÊï∞ÊçÆÔºàÊ®°Êãü‰πãÂâçÁöÑÊïàÊûúÔºâ
  const generateDemoAIIssues = async () => {
    console.log('ÂºÄÂßãÁîüÊàêDemo AIÈóÆÈ¢ò...');
    
    try {
      // ‰∫ßÂìÅÊºîÁ§∫ÁâàÊú¨ÔºöÂøÖÂÆöÁîüÊàêÁªìÊûúÔºåÁõ¥Êé•‰ΩøÁî®È¢ÑËÆæÁöÑÁ¥´Ëâ≤È°µÈù¢Êà™Âõæ
      console.log('‰∫ßÂìÅÊºîÁ§∫Ê®°ÂºèÔºöAIÂøÖÂÆöÊ£ÄÊµãÂà∞Â∑ÆÂºÇÈóÆÈ¢ò');

      // ÂÖàËé∑ÂèñÂü∫Á°ÄÊà™Âõæ
      let baseCanvas;
      try {
        // Â∞ùËØïÊà™ÂèñiframeÂÜÖÂÆπ
        if (iframeRef.current && iframeRef.current.contentDocument) {
          baseCanvas = await html2canvas(iframeRef.current.contentDocument.body, {
            useCORS: true,
            allowTaint: true,
            scale: 1,
            width: designSize.width,
            height: designSize.height
          });
        } else {
          // Â¶ÇÊûúÊó†Ê≥ïËÆøÈóÆiframeÔºåÊà™ÂèñÊï¥‰∏™È¢ÑËßàÂå∫Âüü
          baseCanvas = await html2canvas(document.querySelector('.iframe-wrapper'), {
            useCORS: true,
            allowTaint: true,
            scale: 1
          });
        }
      } catch (error) {
        console.log('Êà™ÂõæÂ§±Ë¥•Ôºå‰ΩøÁî®Â§áÁî®ÊñπÊ°à:', error);
        // ÂàõÂª∫‰∏Ä‰∏™Á¥´Ëâ≤ËÉåÊôØÁöÑcanvas‰Ωú‰∏∫ÊºîÁ§∫
        baseCanvas = document.createElement('canvas');
        baseCanvas.width = designSize.width;
        baseCanvas.height = designSize.height;
        const ctx = baseCanvas.getContext('2d');
        
        // ÁªòÂà∂Á¥´Ëâ≤Ê∏êÂèòËÉåÊôØ
        const gradient = ctx.createLinearGradient(0, 0, 0, baseCanvas.height);
        gradient.addColorStop(0, '#8B5FB8');
        gradient.addColorStop(1, '#6B4B9E');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);
        
        // ÁªòÂà∂Ê†áÈ¢ò
        ctx.fillStyle = 'white';
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('‰∏ì‰∏öÁöÑUIËµ∞Êü•Â∑•ÂÖ∑', baseCanvas.width / 2, baseCanvas.height * 0.3);
        
        // ÁªòÂà∂ÊåâÈíÆ
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(baseCanvas.width / 2 - 60, baseCanvas.height * 0.6 - 20, 120, 40);
        ctx.fillStyle = '#6B4B9E';
        ctx.font = '16px Arial';
        ctx.fillText('Á´ãÂç≥‰ΩìÈ™å', baseCanvas.width / 2, baseCanvas.height * 0.6 + 5);
      }

      // ü§ñ Ëá™Âä®ÂõæÂÉèÂ∑ÆÂºÇÊ£ÄÊµãÂíåÊ°ÜÈÄâÁîüÊàê
      console.log('üîç ÂêØÂä®Ëá™Âä®Â∑ÆÂºÇÊ£ÄÊµãÁÆóÊ≥ï...');
      
      let problemAreas = [];
      
      // Â¶ÇÊûúÊúâËÆæËÆ°ÂõæÔºåÊâßË°åÁúüÊ≠£ÁöÑËá™Âä®Â∑ÆÂºÇÊ£ÄÊµã
      if (aiUploadedImages.length > 0) {
        try {
          const designImg = await loadImage(aiUploadedImages[0].data);
          problemAreas = await performRealDifferenceDetection(baseCanvas, designImg);
          console.log(`‚úÖ Ëá™Âä®Ê£ÄÊµãÂÆåÊàêÔºåÂèëÁé∞ ${problemAreas.length} ‰∏™Â∑ÆÂºÇÂå∫Âüü`);
        } catch (error) {
          console.error('Ëá™Âä®Ê£ÄÊµãÂ§±Ë¥•Ôºå‰ΩøÁî®Â§áÁî®Ê£ÄÊµã:', error);
          problemAreas = await performBasicDifferenceDetection(baseCanvas);
        }
      } else {
        console.log('‚ö†Ô∏è Êó†ËÆæËÆ°ÂõæÔºå‰ΩøÁî®Âü∫Á°ÄÊ£ÄÊµãÁÆóÊ≥ï');
        problemAreas = await performBasicDifferenceDetection(baseCanvas);
      }

      // È¢ÑÂä†ËΩΩËÆæËÆ°Âõæ
      let designImg = null;
      if (aiUploadedImages.length > 0) {
        designImg = await loadImage(aiUploadedImages[0].data);
      }

      const screenshots = [];
      for (const area of problemAreas) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = baseCanvas.width;
        tempCanvas.height = baseCanvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // 1. ÁªòÂà∂Âü∫Á°ÄÊà™Âõæ
        tempCtx.drawImage(baseCanvas, 0, 0);
        
        // 2. Â¶ÇÊûúÊúâËÆæËÆ°ÂõæÔºåÂè†Âä†ÂçäÈÄèÊòéËÆæËÆ°Âõæ
        if (designImg) {
          tempCtx.globalAlpha = 0.4;
          tempCtx.drawImage(designImg, 0, 0, baseCanvas.width, baseCanvas.height);
          tempCtx.globalAlpha = 1.0;
        }
        
        // 3. ÁªòÂà∂ÈÜíÁõÆÁöÑÁ∫¢Ëâ≤ÈóÆÈ¢òÊ†áËÆ∞Ê°Ü - DemoÊºîÁ§∫Â¢ûÂº∫Áâà
        tempCtx.strokeStyle = '#ff0000';
        tempCtx.lineWidth = 4; // Â¢ûÂä†Á∫øÂÆΩÔºåÊõ¥ÈÜíÁõÆ
        tempCtx.strokeRect(area.x, area.y, area.width, area.height);
        
        // 4. ÁªòÂà∂Êõ¥ÊòéÊòæÁöÑÂçäÈÄèÊòéÁ∫¢Ëâ≤Â°´ÂÖÖ
        tempCtx.fillStyle = 'rgba(255, 0, 0, 0.25)'; // Â¢ûÂä†ÈÄèÊòéÂ∫¶ÔºåÊõ¥ÊòéÊòæ
        tempCtx.fillRect(area.x, area.y, area.width, area.height);
        
        // 5. Ê∑ªÂä†ÂèåÈáçËæπÊ°ÜÊïàÊûúÔºåÂ¢ûÂº∫ËßÜËßâÂÜ≤Âáª
        tempCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        tempCtx.lineWidth = 1;
        tempCtx.strokeRect(area.x - 1, area.y - 1, area.width + 2, area.height + 2);
        
        screenshots.push(tempCanvas.toDataURL('image/png'));
      }
      
      const mockIssues = problemAreas.map((area, index) => ({
        id: `ai-${Date.now()}-${index + 1}`,
        screenshot: screenshots[index],
        description: area.description,
        suggestion: area.suggestion,
        status: 'Not Verified',
        source: 'AI Inspection'
      }));

      console.log(`‚úÖ ÊàêÂäüÁîüÊàê ${mockIssues.length} ‰∏™AIÈóÆÈ¢ò`);
      return mockIssues;

    } catch (error) {
      console.error('ÁîüÊàêDemo AIÈóÆÈ¢òÂ§±Ë¥•:', error);
      return [];
    }
  };

  // Â∑≤Âà†Èô§ÂÖúÂ∫ïÊñπÊ°àÔºåÊåâÁî®Êà∑Ë¶ÅÊ±ÇÂΩìÊ£ÄÊµã‰∏çÂà∞Â∑ÆÂºÇÊó∂ÊòæÁ§∫ÊÇ¨ÊµÆÊèêÁ§∫

  // ÁÆÄÂåñÁöÑÂçïÊñá‰ª∂‰∏ä‰º†ÁªÑ‰ª∂
  const DragUpload = ({ onUpload }) => {
    const aiFileInputRef = useRef(null);

    const handleFileChange = (e) => {
      console.log('DragUpload handleFileChange Ë¢´Ë∞ÉÁî®');
      const files = e.target.files;
      console.log('ÈÄâÊã©ÁöÑÊñá‰ª∂:', files ? files.length : 0);
      
      if (files && files.length > 0) {
        console.log('Ë∞ÉÁî®onUploadÂáΩÊï∞ÔºåÊñá‰ª∂:', files[0].name);
        onUpload(files);
      }
      // ÈáçÁΩÆinputÂÄºÔºåÂÖÅËÆ∏ÈÄâÊã©Áõ∏ÂêåÊñá‰ª∂
      e.target.value = '';
    };

    const handleClick = () => {
      if (aiFileInputRef.current) {
        aiFileInputRef.current.click();
      }
    };

    const handleDrop = (e) => {
      e.preventDefault();
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        onUpload(files);
      }
    };

    const handleDragOver = (e) => {
      e.preventDefault();
    };

    return (
      <div>
        <input
          ref={aiFileInputRef}
          type="file"
          accept="image/png,image/jpeg,image/jpg"
          onChange={handleFileChange}
          style={{ display: 'none' }}
        />
        
        <div 
          onClick={handleClick}
          onDrop={handleDrop}
          onDragOver={handleDragOver}
          style={{ 
            cursor: 'pointer', 
            minHeight: '120px',
            border: '2px dashed #ccc',
            borderRadius: '8px',
            padding: '20px',
            textAlign: 'center',
            backgroundColor: '#fafafa'
          }}
        >
          <div style={{ fontSize: '32px', marginBottom: '10px' }}>üé®</div>
          <div style={{ fontSize: '16px', marginBottom: '8px' }}>Click or drag design image here</div>
          <div style={{ fontSize: '12px', color: '#666' }}>
            Supports PNG, JPG, JPEG formats, file size up to 10MB
          </div>
        </div>
      </div>
    );
  };


  const handlePreviewMouseDown = (e) => {
    if (isSelecting) {
      const rect = previewRef.current.getBoundingClientRect();
      setSelectionStart({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      });
    }
  };


  const saveIssue = () => {
    if (currentIssue.description.trim() || currentIssue.suggestion.trim()) {
      const newIssue = {
        id: editingIssueId || Date.now().toString(),
        screenshot: modalScreenshot,
        description: currentIssue.description,
        suggestion: currentIssue.suggestion,
        status: 'Not Verified'
      };

      if (editingIssueId) {
        setIssues(issues.map(issue => 
          issue.id === editingIssueId ? newIssue : issue
        ));
      } else {
        setIssues([...issues, newIssue]);
      }
    }

    setShowModal(false);
    setSelection(null);
    setSelectionStart(null);
    setModalScreenshot(null);
    setCurrentIssue({ description: '', suggestion: '' });
    setEditingIssueId(null);
    // ‰øùÂ≠òÈóÆÈ¢òÂêéÊ∏ÖÈô§Á∫¢Ê°ÜÈ´ò‰∫Æ
    if (previewRef.current) {
      previewRef.current.style.boxShadow = '';
    }
  };

  const editIssue = (issue) => {
    setCurrentIssue({
      description: issue.description,
      suggestion: issue.suggestion
    });
    setModalScreenshot(issue.screenshot);
    setEditingIssueId(issue.id);
    setShowModal(true);
  };

  const deleteIssue = (issueId) => {
    if (window.confirm('Are you sure you want to delete this issue?')) {
      setIssues(issues.filter(issue => issue.id !== issueId));
    }
  };

  // Â∞ÜÂõæÁâáÂéãÁº©‰∏∫Â∞èÂ∞∫ÂØ∏Áº©Áï•Âõæ
  const compressImage = (base64, maxWidth = 150, maxHeight = 100, quality = 0.8) => {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = () => {
        // ËÆ°ÁÆóÂéãÁº©ÂêéÁöÑÂ∞∫ÂØ∏
        let { width, height } = img;
        const ratio = Math.min(maxWidth / width, maxHeight / height);
        width = Math.round(width * ratio);
        height = Math.round(height * ratio);
        
        canvas.width = width;
        canvas.height = height;
        
        // ÁªòÂà∂ÂéãÁº©ÂõæÁâá
        ctx.drawImage(img, 0, 0, width, height);
        
        // ËΩ¨‰∏∫ËæÉ‰ΩéË¥®ÈáèÁöÑbase64
        const compressedBase64 = canvas.toDataURL('image/jpeg', quality);
        resolve(compressedBase64);
      };
      
      img.src = base64;
    });
  };

  const exportToReport = () => {
    if (issues.length === 0) {
      alert('No issue records available for export');
      return;
    }

    try {
      // Áõ¥Êé•‰ΩøÁî®ÂéüÂßãÂõæÁâáÔºå‰∏çÂéãÁº©
      let html = `
        <html>
        <head>
          <meta charset="utf-8">
          <style>
            body { 
              font-family: 'Microsoft YaHei', Arial, sans-serif; 
              margin: 40px;
              line-height: 1.6;
            }
            .issue-item {
              margin-bottom: 50px;
              page-break-inside: avoid;
              border: 1px solid #ddd;
              border-radius: 8px;
              padding: 25px;
              background-color: #fafafa;
            }
            .issue-header {
              background-color: #4472C4;
              color: white;
              padding: 18px 25px;
              margin: -25px -25px 30px -25px;
              border-radius: 7px 7px 0 0;
              font-size: 42px;
              font-weight: bold;
              text-align: center;
            }
            .screenshot {
              max-width: 600px;
              height: auto;
              border: 2px solid #ccc;
              border-radius: 4px;
              display: block;
              margin: 20px auto;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            }
            .info-section {
              margin-top: 25px;
              background-color: #f8f9fa;
              padding: 15px;
              border-radius: 5px;
            }
            .info-label {
              font-weight: bold;
              color: #333;
              margin-bottom: 15px;
              font-size: 32px;
            }
            .info-content {
              background-color: white;
              padding: 25px;
              border: 2px solid #ddd;
              border-radius: 6px;
              margin-bottom: 30px;
              min-height: 80px;
              font-size: 28px;
              line-height: 2.0;
            }
          </style>
        </head>
        <body>
      `;

      issues.forEach((issue, index) => {
        const status = issue.status || 'Not Modified';
        
        html += `
          <div class="issue-item">
            <div class="issue-header">
              Issue ${index + 1}
            </div>
            
            <div style="text-align: center;">
              <img class="screenshot" src="${issue.screenshot}" alt="Issue ${index + 1} screenshot" />
            </div>
            
            <div class="info-section">
              <div class="info-label">Issue Description:</div>
              <div class="info-content">${issue.description || 'No description'}</div>
              
              <div class="info-label">Modification Suggestions:</div>
              <div class="info-content">${issue.suggestion || 'No suggestions'}</div>
              
              <div class="info-label">Verification Status:</div>
              <div class="info-content">Not Verified</div>
            </div>
          </div>
        `;
      });

      html += `
        </body>
        </html>
      `;

      // Create Blob and download as .doc file (Word-compatible HTML format)
      const blob = new Blob([html], { 
        type: 'application/msword;charset=utf-8' 
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `UI_Inspection_Report_${new Date().toISOString().slice(0, 10)}.doc`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

    } catch (error) {
      console.error('Export failed:', error);
      alert('Export failed, please retry: ' + error.message);
    }
  };

  return (
    <div className="app">
      <div className="top-bar">
        <input
          type="text"
          className="url-input"
          placeholder="Please enter the URL of the frontend test page..."
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && loadUrl()}
        />
        <button className="load-button" onClick={loadUrl}>
          Load Page
        </button>
        <button className="load-button" onClick={clearPage} style={{backgroundColor: '#6c757d', borderColor: '#6c757d', marginLeft: '10px'}}>
          Clear Page
        </button>
      </div>

      <div className="main-content">
        <div className="preview-section">
          <div className="preview-controls">
            <div className="control-group">
              <label>Design Size:</label>
              <select 
                className="design-size-selector" 
                onChange={handleDesignSizeChange}
                defaultValue={0}
              >
                {designSizePresets.map((preset, index) => (
                  <option key={index} value={index}>
                    {preset.name}
                  </option>
                ))}
              </select>
            </div>

            <input
              type="file"
              ref={fileInputRef}
              className="file-input"
              accept=".png,.jpg,.jpeg"
              onChange={handleImageUpload}
            />
            <button 
              className="upload-button" 
              onClick={designImage ? removeDesignImage : triggerImageUpload}
              style={{
                backgroundColor: designImage ? '#dc3545' : '#28a745',
                borderColor: designImage ? '#dc3545' : '#28a745'
              }}
              title={designImage ? 'Delete current design image' : 'Supported formats: PNG, JPG, JPEG, image max 10MB'}
            >
              {designImage ? 'Delete Design Image' : 'Upload Design Image'}
            </button>
            
            <button 
              className="upload-button" 
              onClick={() => {
                if (selection && selection.width > 10) {
                  // Â¶ÇÊûúÂ∑≤ÁªèÊúâÈÄâÊã©ÔºåÂàôÊ∏ÖÈô§ÈÄâÊã©ÔºàË∞ÉÁî®cancelSelectionÁ°Æ‰øùÊ∏ÖÈô§Á∫¢Ê°ÜÈ´ò‰∫ÆÔºâ
                  cancelSelection();
                } else if (isSelecting) {
                  // Â¶ÇÊûúÊ≠£Âú®Ê°ÜÈÄâ‰ΩÜÊ≤°ÊúâÈÄâÊã©ÔºåÂàôÂèñÊ∂àÊ°ÜÈÄâ
                  cancelSelection();
                } else {
                  // ÂºÄÂßãÊ°ÜÈÄâ
                  startSelection();
                }
              }}
              style={{
                backgroundColor: (selection && selection.width > 10) ? '#6c757d' : isSelecting ? '#dc3545' : '#ffc107', 
                borderColor: (selection && selection.width > 10) ? '#6c757d' : isSelecting ? '#dc3545' : '#ffc107',
                color: (selection && selection.width > 10) ? 'white' : isSelecting ? 'white' : '#212529'
              }}
              title={
                (selection && selection.width > 10) ? 'Clear current selected area' : 
                isSelecting ? 'Cancel selection mode' : 
                'Manually select problem area'
              }
            >
              {(selection && selection.width > 10) ? 'Clear Selection' : isSelecting ? 'Cancel Selection' : 'Manual Selection'}
            </button>
            
            <button 
              className="ai-review-button" 
              onClick={() => setShowAIModal(true)}
              disabled={isAIProcessing}
              title={isAIProcessing ? "AI Inspection in Progress..." : "Use AI to automatically inspect differences between design and page"}
            >
              ü§ñ AI Inspection
            </button>
            
            
            {isSelecting && !(selection && selection.width > 10) && (
              <div style={{fontSize: '12px', color: '#666', marginLeft: '10px', alignSelf: 'center'}}>
                Please drag to select the problem area
              </div>
            )}
            
            
            
            
            {designImage && (
                <div className="control-group">
                  <label>Opacity:</label>
                  <input
                    type="range"
                    className="control-slider"
                    min="0"
                    max="1"
                    step="0.1"
                    value={imageOpacity}
                    onChange={(e) => setImageOpacity(parseFloat(e.target.value))}
                  />
                  <span>{Math.round((1 - imageOpacity) * 100)}%</span>
                </div>
            )}
          </div>


          <div 
            className="preview-container" 
            id="previewArea"
            ref={previewRef}
            onMouseDown={handlePreviewMouseDown}
          >
            <div 
              className="iframe-wrapper"
              id="frameWrapper"
              style={{
                width: designSize.width,
                height: designSize.height
              }}
            >
              {currentUrl ? (
                <iframe
                  ref={iframeRef}
                  className="preview-iframe"
                  src={currentUrl}
                  title="Web Preview"
                  sandbox="allow-same-origin allow-scripts allow-forms"
                  style={{
                    width: designSize.width,
                    height: designSize.height
                  }}
                />
              ) : (
                <div className="empty-preview-placeholder">
                  <div className="placeholder-content">
                    <h3>Welcome to UI Inspection Tool</h3>
                    <p>Please paste the URL of your frontend test page in the input field above</p>
                    <p className="placeholder-example">Supports: HTTPS websites that allow iframe embedding</p>
                    <div className="video-tutorial-section">
                      <button 
                        className="video-tutorial-btn"
                        onClick={() => setShowVideoTutorial(true)}
                      >
                        <svg className="tutorial-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                          <path d="M8 5V19L19 12L8 5Z" fill="currentColor"/>
                        </svg>
                        Usage Tutorial
                      </button>
                      <p className="tutorial-desc">Watch video to learn complete usage flow</p>
                    </div>
                    <div className="placeholder-notice">
                      <p>Note: This tool does not currently support saving user history records, but you can export inspection reports</p>
                    </div>
                  </div>
                </div>
              )}
              
              {designImage && (
              <div
                className={`design-overlay ${isDragging ? 'dragging' : ''} ${isResizing ? 'resizing' : ''}`}
                style={{
                  left: imagePosition.x,
                  top: imagePosition.y,
                  width: imageSize.width,
                  height: imageSize.height,
                  opacity: imageOpacity,
                  position: 'absolute',
                  transform: `scale(${imageScale})`,
                  transformOrigin: imageTransformOrigin,
                  transition: isResizing ? 'none' : 'transform 0.1s ease'
                }}
                onMouseDown={handleImageMouseDown}
              >
                <img
                  className="design-image"
                  src={designImage}
                  alt="ËÆæËÆ°Âõæ"
                  draggable={false}
                  style={{ 
                    width: '100%',
                    height: '100%',
                    objectFit: 'contain'
                  }}
                />
                
                {/* 8 resize control points */}
                <div className="resize-handle nw" onMouseDown={(e) => handleResizeMouseDown(e, 'nw')} title="Drag to resize" />
                <div className="resize-handle n" onMouseDown={(e) => handleResizeMouseDown(e, 'n')} title="Drag to resize" />
                <div className="resize-handle ne" onMouseDown={(e) => handleResizeMouseDown(e, 'ne')} title="Drag to resize" />
                <div className="resize-handle e" onMouseDown={(e) => handleResizeMouseDown(e, 'e')} title="Drag to resize" />
                <div className="resize-handle se" onMouseDown={(e) => handleResizeMouseDown(e, 'se')} title="Drag to resize" />
                <div className="resize-handle s" onMouseDown={(e) => handleResizeMouseDown(e, 's')} title="Drag to resize" />
                <div className="resize-handle sw" onMouseDown={(e) => handleResizeMouseDown(e, 'sw')} title="Drag to resize" />
                <div className="resize-handle w" onMouseDown={(e) => handleResizeMouseDown(e, 'w')} title="Drag to resize" />
              </div>
            )}

            <div className={`selection-overlay ${isSelecting ? 'selecting' : ''}`}>
              {selection && (
                <div
                  className="selection-box"
                  style={{
                    left: selection.left,
                    top: selection.top,
                    width: selection.width,
                    height: selection.height
                  }}
                />
              )}
            </div>
            </div>
          </div>
        </div>

        <div className="issues-panel">
          <div className="issues-header">
            <h3 className="issues-title">Issue List ({issues.length})</h3>
            <button className="export-button" onClick={exportToReport} disabled={issues.length === 0}>
              Export Inspection Report
            </button>
          </div>
          
          <div className="issues-list">
            {/* Show paste screenshot button after user completes selection */}
            {selection && selection.width > 10 && (
              <div className="paste-screenshot-section">
                <div className="paste-instruction">
                  <span>üì∏ Please take a screenshot within the red frame area (Win+Shift+S), then click the button below to paste</span>
                  {!isClipboardSupported() && (
                    <div style={{color: '#ff6b6b', fontSize: '12px', marginTop: '8px'}}>
                      ‚ö†Ô∏è Current environment requires HTTPS to access clipboard
                    </div>
                  )}
                </div>
                <button className="paste-screenshot-button" onClick={handlePasteScreenshot}>
                  üìã Paste Screenshot
                </button>
              </div>
            )}
            
            {/* Batch operation control bar */}
            {issues.length > 0 && (
              <div className="batch-controls" style={{ 
                display: 'flex', 
                justifyContent: 'flex-start',
                alignItems: 'center', 
                padding: '16px 0', 
                borderBottom: '1px solid #eee',
                marginBottom: '20px',
                minHeight: '48px',
                gap: '12px',
                flexWrap: 'wrap'
              }}>
                <button 
                  onClick={toggleMultiSelectMode}
                  style={{
                    background: isMultiSelectMode ? '#1890FF' : '#f0f0f0',
                    color: isMultiSelectMode ? 'white' : '#333',
                    border: 'none',
                    padding: '8px 16px',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '12px',
                    whiteSpace: 'nowrap'
                  }}
                >
                  {isMultiSelectMode ? 'Exit Batch' : 'Batch Select'}
                </button>
                
                {isMultiSelectMode && (
                  <>
                    <button 
                      onClick={selectAllIssues}
                      style={{
                        background: 'transparent',
                        color: '#1890FF',
                        border: '1px solid #1890FF',
                        padding: '8px 16px',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '12px',
                        whiteSpace: 'nowrap'
                      }}
                    >
                      Select All
                    </button>
                    <button 
                      onClick={deselectAllIssues}
                      style={{
                        background: 'transparent',
                        color: '#666',
                        border: '1px solid #ccc',
                        padding: '8px 16px',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '12px',
                        whiteSpace: 'nowrap'
                      }}
                    >
                      Deselect All
                    </button>
                    
                    {selectedIssues.size > 0 && (
                      <button 
                        onClick={batchDeleteIssues}
                        style={{
                          background: '#ff4d4f',
                          color: 'white',
                          border: 'none',
                          padding: '8px 16px',
                          borderRadius: '4px',
                          cursor: 'pointer',
                          fontSize: '12px',
                          whiteSpace: 'nowrap'
                        }}
                      >
                        Delete Selected ({selectedIssues.size})
                      </button>
                    )}
                  </>
                )}
              </div>
            )}
            
            {issues.length === 0 ? (
              <div style={{ textAlign: 'center', color: '#666', marginTop: '50px' }}>
                No issue records yet
                <br />
                <small>Supports "Manual Inspection" or "AI Inspection" to record actual page issues</small>
              </div>
            ) : (
              issues.map((issue) => (
                <div key={issue.id} className={`issue-item ${issue.source === 'AI Inspection' ? 'ai-generated' : ''} ${selectedIssues.has(issue.id) ? 'selected' : ''}`} 
                     style={{ 
                       position: 'relative',
                       border: selectedIssues.has(issue.id) ? '2px solid #1890FF' : undefined,
                       backgroundColor: selectedIssues.has(issue.id) ? 'rgba(24, 144, 255, 0.05)' : undefined
                     }}>
                  {/* Batch selection checkbox */}
                  {isMultiSelectMode && (
                    <input
                      type="checkbox"
                      checked={selectedIssues.has(issue.id)}
                      onChange={() => toggleIssueSelection(issue.id)}
                      style={{
                        position: 'absolute',
                        top: '12px',
                        left: '12px',
                        width: '16px',
                        height: '16px',
                        zIndex: 15,
                        cursor: 'pointer'
                      }}
                    />
                  )}
                  
                  {issue.source === 'AI Inspection' && (
                    <div className="ai-badge" style={{
                      position: 'absolute',
                      top: '8px',
                      right: '8px',
                      background: '#1890FF',
                      color: 'white',
                      padding: '4px 8px',
                      borderRadius: '4px',
                      fontSize: '12px',
                      fontWeight: 'bold',
                      zIndex: 10
                    }}>
                      AI Found
                    </div>
                  )}
                  <img
                    className="issue-screenshot"
                    src={issue.screenshot}
                    alt="Issue screenshot"
                    onDoubleClick={() => setEnlargedImage(issue.screenshot)}
                    title="Double click to enlarge"
                    style={{ 
                      marginTop: issue.source === 'AI Inspection' ? '20px' : '0'
                    }}
                  />
                  <div className="issue-description">
                    <div className="issue-label">Issue Description:</div>
                    <div className="issue-text">{issue.description || 'No description'}</div>
                    {issue.pageInfo && (
                      <div className="page-info-tag">
                        üìÑ {issue.pageInfo.title} ({issue.pageInfo.pathname})
                      </div>
                    )}
                    {issue.matchedDesign && (
                      <div className="matched-design-tag">
                        üé® Matched Design: {issue.matchedDesign}
                      </div>
                    )}
                  </div>
                  <div className="issue-suggestion">
                    <div className="issue-label">Modification Suggestions:</div>
                    <div className="issue-text">{issue.suggestion || 'No suggestions'}</div>
                  </div>
                  <div className="issue-actions">
                    <button className="edit-button" onClick={() => editIssue(issue)}>
                      Edit
                    </button>
                    <button className="delete-button" onClick={() => deleteIssue(issue.id)}>
                      Delete
                    </button>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </div>

      {showScreenshotTip && (
        <div className="screenshot-tip">
          <div className="tip-content">
            <span className="tip-text">
              üì∏ You can take a screenshot within the red frame area. Please use Win+Shift+S, then click "Paste Screenshot" in the issue list after completing the screenshot
            </span>
            <button className="tip-close" onClick={closeScreenshotTip}>√ó</button>
          </div>
        </div>
      )}

      {/* Page change detection notification */}
      {pageChangeDetected && isMultiPageMode && (
        <div className="page-change-notification">
          <div className="notification-content">
            <span className="notification-icon">üîÑ</span>
            <span className="notification-text">
              Page change detected: {currentPageInfo?.title || 'Unknown page'}
              {autoScreenshotEnabled && ' - Auto-screenshotting...'}
            </span>
          </div>
        </div>
      )}

      {/* Multi-page information panel */}
      {isMultiPageMode && Object.keys(pageScreenshots).length > 0 && (
        <div className="multi-page-info-panel">
          <div className="info-panel-header">
            <h4>üìÅ Multi-page Screenshot Records</h4>
            <div className="panel-header-actions">
              <button 
                className="panel-toggle" 
                onClick={() => setShowPagePanel(!showPagePanel)}
              >
                {showPagePanel ? 'Collapse' : 'Expand'}
              </button>
            </div>
          </div>
          
          {showPagePanel && (
            <div className="pages-grid">
              {Object.entries(pageScreenshots).map(([pageKey, pageData]) => {
                const matchInfo = designImageMatching[pageKey];
                return (
                  <div key={pageKey} className="page-card">
                    <div className="page-thumbnail">
                      <img 
                        src={pageData.screenshot} 
                        alt={pageData.pageInfo.title}
                        onClick={() => setEnlargedImage(pageData.screenshot)}
                      />
                    </div>
                    <div className="page-info">
                      <div className="page-title">{pageData.pageInfo.title}</div>
                      <div className="page-url">{pageData.pageInfo.pathname}</div>
                      <div className="page-type">Type: {pageData.pageInfo.pageType}</div>
                      {matchInfo ? (
                        <div className="match-info success">
                          ‚úÖ Matched: {matchInfo.designImage.name} ({(matchInfo.score * 100).toFixed(0)}%)
                        </div>
                      ) : (
                        <div className="match-info no-match">
                          ‚ö†Ô∏è No matching design found
                        </div>
                      )}
                      <div className="page-actions">
                        <div style={{ fontSize: '12px', color: '#666' }}>
                          Click image to enlarge
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </div>
      )}

      {showModal && (
        <div className="modal-overlay">
          <div className="modal">
            <h3 className="modal-title">
              {editingIssueId ? 'Edit Issue' : 'Add Issue'}
            </h3>
            
            <img
              className="modal-screenshot"
              src={modalScreenshot}
              alt="Screenshot"
              onDoubleClick={() => setEnlargedImage(modalScreenshot)}
              title="Double click to enlarge"
            />

            <div className="form-group">
              <label className="form-label">Issue Description</label>
              <textarea
                className="form-textarea"
                value={currentIssue.description}
                onChange={(e) => setCurrentIssue({...currentIssue, description: e.target.value})}
                placeholder="Please describe the specific issue, such as: button position 5px to the left, inconsistent title font size, background color doesn't match design, etc."
              />
              <div className="form-placeholder">
                Tip: Please describe the issue in detail, including position, size, color and other specific information
              </div>
            </div>

            <div className="form-group">
              <label className="form-label">Modification Suggestions</label>
              <textarea
                className="form-textarea"
                value={currentIssue.suggestion}
                onChange={(e) => setCurrentIssue({...currentIssue, suggestion: e.target.value})}
                placeholder="Please provide precise modification values, such as: move button 5px to the right, change font size to 16px, change color to #1890FF, change line-height to 1.5, etc."
              />
              <div className="form-placeholder">
                Tip: Please provide specific pixel values, color values, font sizes and other precise numerical values for developers to modify directly
              </div>
            </div>

            <div className="modal-actions">
              <button 
                className="modal-button secondary" 
                onClick={() => {
                  setShowModal(false);
                  setSelection(null);
                  setSelectionStart(null);
                  setCurrentIssue({ description: '', suggestion: '' });
                  setEditingIssueId(null);
                  // Clear red frame highlight when cancelling
                  if (previewRef.current) {
                    previewRef.current.style.boxShadow = '';
                  }
                }}
              >
                Cancel
              </button>
              <button className="modal-button primary" onClick={saveIssue}>
                {editingIssueId ? 'Save Changes' : 'Add Issue'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* AI Inspection Modal */}
      {showAIModal && (
        <div className="modal-overlay">
          <div className="ai-modal" style={{ overflow: isAIProcessing ? 'hidden' : 'auto' }}>
            <h3 className="modal-title">
              ü§ñ AI Smart Inspection
            </h3>
            
            {!isAIProcessing ? (
              <>
                <div className="ai-upload-section">
                  <div className="upload-tabs">
                    <div className="tab-content">
                      <h4>Upload Design Image</h4>
                      <p className="upload-description">
                        Upload the design image for the current page. AI will automatically compare the design mockup with the page implementation, identify differences, and generate issue reports.
                      </p>
                      
                      {/* Single file upload area */}
                      <DragUpload onUpload={handleAIImageUpload} />
                    </div>
                  </div>
                  
                  {/* Display uploaded design image */}
                  {aiUploadedImages.length > 0 && (
                    <div className="uploaded-design">
                      <h4>Design Preview</h4>
                      <div className="design-preview" style={{ position: 'relative', display: 'inline-block' }}>
                        <img 
                          src={aiUploadedImages[0].data} 
                          alt={aiUploadedImages[0].name}
                          style={{ 
                            maxWidth: '300px', 
                            maxHeight: '200px', 
                            border: '1px solid #ddd',
                            borderRadius: '4px',
                            display: 'block'
                          }}
                        />
                        <button 
                          onClick={() => setAiUploadedImages([])}
                          style={{
                            position: 'absolute',
                            top: '5px',
                            right: '5px',
                            background: 'rgba(0,0,0,0.6)',
                            color: 'white',
                            border: 'none',
                            width: '24px',
                            height: '24px',
                            borderRadius: '50%',
                            fontSize: '14px',
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontWeight: 'bold'
                          }}
                          title="Remove design image"
                        >
                          √ó
                        </button>
                        <div className="design-name" style={{ 
                          marginTop: '8px', 
                          fontSize: '14px', 
                          color: '#333',
                          textAlign: 'center'
                        }}>
                          {aiUploadedImages[0].name}
                        </div>
                      </div>
                    </div>
                  )}
                </div>
                

                <div className="modal-actions">
                  <button 
                    className="modal-button secondary" 
                    onClick={() => {
                      setShowAIModal(false);
                      setAiUploadedImages([]);
                    }}
                  >
                    Cancel
                  </button>
                  <button 
                    className="modal-button primary" 
                    onClick={startAIInspection}
                    disabled={aiUploadedImages.length === 0}
                  >
                    Start AI Inspection
                  </button>
                </div>
              </>
            ) : (
              <div className="ai-processing" style={{ overflow: 'hidden' }}>
                <div className="processing-header">
                  <div className="processing-icon">üîÑ</div>
                  <h4>AI Inspection in Progress...</h4>
                </div>
                
                <div className="progress-container">
                  <div className="progress-bar">
                    <div 
                      className="progress-fill"
                      style={{ width: `${aiProgress.progress}%` }}
                    />
                  </div>
                  <div className="progress-text">{aiProgress.step}</div>
                  <div className="progress-percentage">{aiProgress.progress}%</div>
                </div>
                
                <div className="processing-info">
                  <p>Analyzing differences between your design and page, please wait...</p>
                  <p>After analysis is complete, issues will be automatically added to the issue list on the right.</p>
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      {/* AI no differences detected floating notification */}
      {showNoDiffToast && (
        <div style={{
          position: 'fixed',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          color: 'white',
          padding: '20px 30px',
          borderRadius: '8px',
          fontSize: '16px',
          fontWeight: 'bold',
          zIndex: 10000,
          boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',
          animation: 'fadeInOut 3s ease-in-out forwards'
        }}>
          ü§ñ AI Could Not Detect Obvious Differences
        </div>
      )}

      {/* Image enlargement modal */}
      {enlargedImage && (
        <div className="image-enlargement-overlay" onClick={() => setEnlargedImage(null)}>
          <div className="image-enlargement-container" onClick={e => e.stopPropagation()}>
            <button 
              className="image-close-button" 
              onClick={() => setEnlargedImage(null)}
              title="Close"
            >
              √ó
            </button>
            <img 
              className="enlarged-image" 
              src={enlargedImage} 
              alt="Enlarged view" 
              onDoubleClick={() => setEnlargedImage(null)}
            />
            <div className="image-enlargement-tip">
              Double-click image or click background to close
            </div>
          </div>
        </div>
      )}

      {/* Video tutorial modal */}
      {showVideoTutorial && (
        <div className="modal-overlay">
          <div className="video-tutorial-modal">
            <div className="video-tutorial-header">
              <h3>üìπ User Tutorial</h3>
              <button 
                className="modal-close-btn"
                onClick={() => setShowVideoTutorial(false)}
              >
                √ó
              </button>
            </div>
            <div className="video-tutorial-content">
              <video
                controls
                width="100%"
                height="400"
                style={{ borderRadius: '8px' }}
              >
                <source src="/tutorial-video.mp4" type="video/mp4" />
                Your browser does not support video playback. Please upgrade to the latest version of your browser.
              </video>
              <p className="video-description">
                This video demonstrates the complete usage flow of the UI inspection tool, including page loading, design image upload, issue marking, and report export functions.
              </p>
            </div>
            <div className="video-tutorial-actions">
              <button 
                className="modal-button primary"
                onClick={() => setShowVideoTutorial(false)}
              >
                Got it
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

export default App;
